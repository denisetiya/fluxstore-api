
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Alamat
 * 
 */
export type Alamat = $Result.DefaultSelection<Prisma.$AlamatPayload>
/**
 * Model CategoryProduct
 * 
 */
export type CategoryProduct = $Result.DefaultSelection<Prisma.$CategoryProductPayload>
/**
 * Model SubCategoryProduct
 * 
 */
export type SubCategoryProduct = $Result.DefaultSelection<Prisma.$SubCategoryProductPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductDetail
 * 
 */
export type ProductDetail = $Result.DefaultSelection<Prisma.$ProductDetailPayload>
/**
 * Model Size
 * 
 */
export type Size = $Result.DefaultSelection<Prisma.$SizePayload>
/**
 * Model comentsProduct
 * 
 */
export type comentsProduct = $Result.DefaultSelection<Prisma.$comentsProductPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.alamat`: Exposes CRUD operations for the **Alamat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alamats
    * const alamats = await prisma.alamat.findMany()
    * ```
    */
  get alamat(): Prisma.AlamatDelegate<ExtArgs>;

  /**
   * `prisma.categoryProduct`: Exposes CRUD operations for the **CategoryProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryProducts
    * const categoryProducts = await prisma.categoryProduct.findMany()
    * ```
    */
  get categoryProduct(): Prisma.CategoryProductDelegate<ExtArgs>;

  /**
   * `prisma.subCategoryProduct`: Exposes CRUD operations for the **SubCategoryProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategoryProducts
    * const subCategoryProducts = await prisma.subCategoryProduct.findMany()
    * ```
    */
  get subCategoryProduct(): Prisma.SubCategoryProductDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productDetail`: Exposes CRUD operations for the **ProductDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductDetails
    * const productDetails = await prisma.productDetail.findMany()
    * ```
    */
  get productDetail(): Prisma.ProductDetailDelegate<ExtArgs>;

  /**
   * `prisma.size`: Exposes CRUD operations for the **Size** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sizes
    * const sizes = await prisma.size.findMany()
    * ```
    */
  get size(): Prisma.SizeDelegate<ExtArgs>;

  /**
   * `prisma.comentsProduct`: Exposes CRUD operations for the **comentsProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComentsProducts
    * const comentsProducts = await prisma.comentsProduct.findMany()
    * ```
    */
  get comentsProduct(): Prisma.comentsProductDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Alamat: 'Alamat',
    CategoryProduct: 'CategoryProduct',
    SubCategoryProduct: 'SubCategoryProduct',
    Product: 'Product',
    ProductDetail: 'ProductDetail',
    Size: 'Size',
    comentsProduct: 'comentsProduct'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'alamat' | 'categoryProduct' | 'subCategoryProduct' | 'product' | 'productDetail' | 'size' | 'comentsProduct'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Alamat: {
        payload: Prisma.$AlamatPayload<ExtArgs>
        fields: Prisma.AlamatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlamatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlamatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload>
          }
          findFirst: {
            args: Prisma.AlamatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlamatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload>
          }
          findMany: {
            args: Prisma.AlamatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload>[]
          }
          create: {
            args: Prisma.AlamatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload>
          }
          createMany: {
            args: Prisma.AlamatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AlamatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload>
          }
          update: {
            args: Prisma.AlamatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload>
          }
          deleteMany: {
            args: Prisma.AlamatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AlamatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AlamatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AlamatPayload>
          }
          aggregate: {
            args: Prisma.AlamatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlamat>
          }
          groupBy: {
            args: Prisma.AlamatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AlamatGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlamatCountArgs<ExtArgs>,
            result: $Utils.Optional<AlamatCountAggregateOutputType> | number
          }
        }
      }
      CategoryProduct: {
        payload: Prisma.$CategoryProductPayload<ExtArgs>
        fields: Prisma.CategoryProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload>
          }
          findFirst: {
            args: Prisma.CategoryProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload>
          }
          findMany: {
            args: Prisma.CategoryProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload>[]
          }
          create: {
            args: Prisma.CategoryProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload>
          }
          createMany: {
            args: Prisma.CategoryProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload>
          }
          update: {
            args: Prisma.CategoryProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload>
          }
          deleteMany: {
            args: Prisma.CategoryProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryProductPayload>
          }
          aggregate: {
            args: Prisma.CategoryProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoryProduct>
          }
          groupBy: {
            args: Prisma.CategoryProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryProductCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryProductCountAggregateOutputType> | number
          }
        }
      }
      SubCategoryProduct: {
        payload: Prisma.$SubCategoryProductPayload<ExtArgs>
        fields: Prisma.SubCategoryProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoryProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoryProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload>
          }
          findFirst: {
            args: Prisma.SubCategoryProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoryProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload>
          }
          findMany: {
            args: Prisma.SubCategoryProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload>[]
          }
          create: {
            args: Prisma.SubCategoryProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload>
          }
          createMany: {
            args: Prisma.SubCategoryProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubCategoryProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload>
          }
          update: {
            args: Prisma.SubCategoryProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoryProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoryProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoryProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubCategoryProductPayload>
          }
          aggregate: {
            args: Prisma.SubCategoryProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubCategoryProduct>
          }
          groupBy: {
            args: Prisma.SubCategoryProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubCategoryProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoryProductCountArgs<ExtArgs>,
            result: $Utils.Optional<SubCategoryProductCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductDetail: {
        payload: Prisma.$ProductDetailPayload<ExtArgs>
        fields: Prisma.ProductDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductDetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductDetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          findFirst: {
            args: Prisma.ProductDetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductDetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          findMany: {
            args: Prisma.ProductDetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>[]
          }
          create: {
            args: Prisma.ProductDetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          createMany: {
            args: Prisma.ProductDetailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          update: {
            args: Prisma.ProductDetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          deleteMany: {
            args: Prisma.ProductDetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductDetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductDetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          aggregate: {
            args: Prisma.ProductDetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductDetail>
          }
          groupBy: {
            args: Prisma.ProductDetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductDetailCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductDetailCountAggregateOutputType> | number
          }
        }
      }
      Size: {
        payload: Prisma.$SizePayload<ExtArgs>
        fields: Prisma.SizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SizeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SizeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          findFirst: {
            args: Prisma.SizeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SizeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          findMany: {
            args: Prisma.SizeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload>[]
          }
          create: {
            args: Prisma.SizeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          createMany: {
            args: Prisma.SizeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SizeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          update: {
            args: Prisma.SizeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          deleteMany: {
            args: Prisma.SizeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SizeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SizeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          aggregate: {
            args: Prisma.SizeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSize>
          }
          groupBy: {
            args: Prisma.SizeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SizeCountArgs<ExtArgs>,
            result: $Utils.Optional<SizeCountAggregateOutputType> | number
          }
        }
      }
      comentsProduct: {
        payload: Prisma.$comentsProductPayload<ExtArgs>
        fields: Prisma.comentsProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comentsProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comentsProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload>
          }
          findFirst: {
            args: Prisma.comentsProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comentsProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload>
          }
          findMany: {
            args: Prisma.comentsProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload>[]
          }
          create: {
            args: Prisma.comentsProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload>
          }
          createMany: {
            args: Prisma.comentsProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.comentsProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload>
          }
          update: {
            args: Prisma.comentsProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload>
          }
          deleteMany: {
            args: Prisma.comentsProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.comentsProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.comentsProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comentsProductPayload>
          }
          aggregate: {
            args: Prisma.ComentsProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComentsProduct>
          }
          groupBy: {
            args: Prisma.comentsProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComentsProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.comentsProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ComentsProductCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    comentsUser: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentsUser?: boolean | UserCountOutputTypeCountComentsUserArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComentsUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentsProductWhereInput
  }



  /**
   * Count Type CategoryProductCountOutputType
   */

  export type CategoryProductCountOutputType = {
    subCategories: number
  }

  export type CategoryProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | CategoryProductCountOutputTypeCountSubCategoriesArgs
  }

  // Custom InputTypes

  /**
   * CategoryProductCountOutputType without action
   */
  export type CategoryProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProductCountOutputType
     */
    select?: CategoryProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryProductCountOutputType without action
   */
  export type CategoryProductCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryProductWhereInput
  }



  /**
   * Count Type SubCategoryProductCountOutputType
   */

  export type SubCategoryProductCountOutputType = {
    products: number
  }

  export type SubCategoryProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SubCategoryProductCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes

  /**
   * SubCategoryProductCountOutputType without action
   */
  export type SubCategoryProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProductCountOutputType
     */
    select?: SubCategoryProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SubCategoryProductCountOutputType without action
   */
  export type SubCategoryProductCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    comentsProduct: number
    productDetails: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentsProduct?: boolean | ProductCountOutputTypeCountComentsProductArgs
    productDetails?: boolean | ProductCountOutputTypeCountProductDetailsArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountComentsProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentsProductWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDetailWhereInput
  }



  /**
   * Count Type ProductDetailCountOutputType
   */

  export type ProductDetailCountOutputType = {
    sizes: number
  }

  export type ProductDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sizes?: boolean | ProductDetailCountOutputTypeCountSizesArgs
  }

  // Custom InputTypes

  /**
   * ProductDetailCountOutputType without action
   */
  export type ProductDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailCountOutputType
     */
    select?: ProductDetailCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductDetailCountOutputType without action
   */
  export type ProductDetailCountOutputTypeCountSizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    profilePic: string | null
    superUser: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    phoneNumber: string | null
    profilePic: string | null
    superUser: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    phoneNumber: number
    profilePic: number
    superUser: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    profilePic?: true
    superUser?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    profilePic?: true
    superUser?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    phoneNumber?: true
    profilePic?: true
    superUser?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    phoneNumber: string | null
    profilePic: string | null
    superUser: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    profilePic?: boolean
    superUser?: boolean
    alamat?: boolean | User$alamatArgs<ExtArgs>
    comentsUser?: boolean | User$comentsUserArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    phoneNumber?: boolean
    profilePic?: boolean
    superUser?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alamat?: boolean | User$alamatArgs<ExtArgs>
    comentsUser?: boolean | User$comentsUserArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      alamat: Prisma.$AlamatPayload<ExtArgs> | null
      comentsUser: Prisma.$comentsProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      phoneNumber: string | null
      profilePic: string | null
      superUser: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    alamat<T extends User$alamatArgs<ExtArgs> = {}>(args?: Subset<T, User$alamatArgs<ExtArgs>>): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    comentsUser<T extends User$comentsUserArgs<ExtArgs> = {}>(args?: Subset<T, User$comentsUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly profilePic: FieldRef<"User", 'String'>
    readonly superUser: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.alamat
   */
  export type User$alamatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    where?: AlamatWhereInput
  }


  /**
   * User.comentsUser
   */
  export type User$comentsUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    where?: comentsProductWhereInput
    orderBy?: comentsProductOrderByWithRelationInput | comentsProductOrderByWithRelationInput[]
    cursor?: comentsProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentsProductScalarFieldEnum | ComentsProductScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Alamat
   */

  export type AggregateAlamat = {
    _count: AlamatCountAggregateOutputType | null
    _min: AlamatMinAggregateOutputType | null
    _max: AlamatMaxAggregateOutputType | null
  }

  export type AlamatMinAggregateOutputType = {
    id: string | null
    idUser: string | null
    provinsi: string | null
    kabupaten: string | null
    kecamatan: string | null
    kodepos: string | null
    detail: string | null
  }

  export type AlamatMaxAggregateOutputType = {
    id: string | null
    idUser: string | null
    provinsi: string | null
    kabupaten: string | null
    kecamatan: string | null
    kodepos: string | null
    detail: string | null
  }

  export type AlamatCountAggregateOutputType = {
    id: number
    idUser: number
    provinsi: number
    kabupaten: number
    kecamatan: number
    kodepos: number
    detail: number
    _all: number
  }


  export type AlamatMinAggregateInputType = {
    id?: true
    idUser?: true
    provinsi?: true
    kabupaten?: true
    kecamatan?: true
    kodepos?: true
    detail?: true
  }

  export type AlamatMaxAggregateInputType = {
    id?: true
    idUser?: true
    provinsi?: true
    kabupaten?: true
    kecamatan?: true
    kodepos?: true
    detail?: true
  }

  export type AlamatCountAggregateInputType = {
    id?: true
    idUser?: true
    provinsi?: true
    kabupaten?: true
    kecamatan?: true
    kodepos?: true
    detail?: true
    _all?: true
  }

  export type AlamatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alamat to aggregate.
     */
    where?: AlamatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alamats to fetch.
     */
    orderBy?: AlamatOrderByWithRelationInput | AlamatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlamatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alamats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alamats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alamats
    **/
    _count?: true | AlamatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlamatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlamatMaxAggregateInputType
  }

  export type GetAlamatAggregateType<T extends AlamatAggregateArgs> = {
        [P in keyof T & keyof AggregateAlamat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlamat[P]>
      : GetScalarType<T[P], AggregateAlamat[P]>
  }




  export type AlamatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlamatWhereInput
    orderBy?: AlamatOrderByWithAggregationInput | AlamatOrderByWithAggregationInput[]
    by: AlamatScalarFieldEnum[] | AlamatScalarFieldEnum
    having?: AlamatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlamatCountAggregateInputType | true
    _min?: AlamatMinAggregateInputType
    _max?: AlamatMaxAggregateInputType
  }

  export type AlamatGroupByOutputType = {
    id: string
    idUser: string
    provinsi: string
    kabupaten: string
    kecamatan: string
    kodepos: string
    detail: string
    _count: AlamatCountAggregateOutputType | null
    _min: AlamatMinAggregateOutputType | null
    _max: AlamatMaxAggregateOutputType | null
  }

  type GetAlamatGroupByPayload<T extends AlamatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlamatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlamatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlamatGroupByOutputType[P]>
            : GetScalarType<T[P], AlamatGroupByOutputType[P]>
        }
      >
    >


  export type AlamatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idUser?: boolean
    provinsi?: boolean
    kabupaten?: boolean
    kecamatan?: boolean
    kodepos?: boolean
    detail?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alamat"]>

  export type AlamatSelectScalar = {
    id?: boolean
    idUser?: boolean
    provinsi?: boolean
    kabupaten?: boolean
    kecamatan?: boolean
    kodepos?: boolean
    detail?: boolean
  }

  export type AlamatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AlamatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alamat"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idUser: string
      provinsi: string
      kabupaten: string
      kecamatan: string
      kodepos: string
      detail: string
    }, ExtArgs["result"]["alamat"]>
    composites: {}
  }


  type AlamatGetPayload<S extends boolean | null | undefined | AlamatDefaultArgs> = $Result.GetResult<Prisma.$AlamatPayload, S>

  type AlamatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlamatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlamatCountAggregateInputType | true
    }

  export interface AlamatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alamat'], meta: { name: 'Alamat' } }
    /**
     * Find zero or one Alamat that matches the filter.
     * @param {AlamatFindUniqueArgs} args - Arguments to find a Alamat
     * @example
     * // Get one Alamat
     * const alamat = await prisma.alamat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlamatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AlamatFindUniqueArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Alamat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlamatFindUniqueOrThrowArgs} args - Arguments to find a Alamat
     * @example
     * // Get one Alamat
     * const alamat = await prisma.alamat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlamatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlamatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Alamat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlamatFindFirstArgs} args - Arguments to find a Alamat
     * @example
     * // Get one Alamat
     * const alamat = await prisma.alamat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlamatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AlamatFindFirstArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Alamat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlamatFindFirstOrThrowArgs} args - Arguments to find a Alamat
     * @example
     * // Get one Alamat
     * const alamat = await prisma.alamat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlamatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlamatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Alamats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlamatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alamats
     * const alamats = await prisma.alamat.findMany()
     * 
     * // Get first 10 Alamats
     * const alamats = await prisma.alamat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alamatWithIdOnly = await prisma.alamat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlamatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlamatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Alamat.
     * @param {AlamatCreateArgs} args - Arguments to create a Alamat.
     * @example
     * // Create one Alamat
     * const Alamat = await prisma.alamat.create({
     *   data: {
     *     // ... data to create a Alamat
     *   }
     * })
     * 
    **/
    create<T extends AlamatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AlamatCreateArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Alamats.
     *     @param {AlamatCreateManyArgs} args - Arguments to create many Alamats.
     *     @example
     *     // Create many Alamats
     *     const alamat = await prisma.alamat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlamatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlamatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alamat.
     * @param {AlamatDeleteArgs} args - Arguments to delete one Alamat.
     * @example
     * // Delete one Alamat
     * const Alamat = await prisma.alamat.delete({
     *   where: {
     *     // ... filter to delete one Alamat
     *   }
     * })
     * 
    **/
    delete<T extends AlamatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AlamatDeleteArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Alamat.
     * @param {AlamatUpdateArgs} args - Arguments to update one Alamat.
     * @example
     * // Update one Alamat
     * const alamat = await prisma.alamat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlamatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AlamatUpdateArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Alamats.
     * @param {AlamatDeleteManyArgs} args - Arguments to filter Alamats to delete.
     * @example
     * // Delete a few Alamats
     * const { count } = await prisma.alamat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlamatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlamatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alamats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlamatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alamats
     * const alamat = await prisma.alamat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlamatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AlamatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alamat.
     * @param {AlamatUpsertArgs} args - Arguments to update or create a Alamat.
     * @example
     * // Update or create a Alamat
     * const alamat = await prisma.alamat.upsert({
     *   create: {
     *     // ... data to create a Alamat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alamat we want to update
     *   }
     * })
    **/
    upsert<T extends AlamatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AlamatUpsertArgs<ExtArgs>>
    ): Prisma__AlamatClient<$Result.GetResult<Prisma.$AlamatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Alamats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlamatCountArgs} args - Arguments to filter Alamats to count.
     * @example
     * // Count the number of Alamats
     * const count = await prisma.alamat.count({
     *   where: {
     *     // ... the filter for the Alamats we want to count
     *   }
     * })
    **/
    count<T extends AlamatCountArgs>(
      args?: Subset<T, AlamatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlamatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alamat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlamatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlamatAggregateArgs>(args: Subset<T, AlamatAggregateArgs>): Prisma.PrismaPromise<GetAlamatAggregateType<T>>

    /**
     * Group by Alamat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlamatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlamatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlamatGroupByArgs['orderBy'] }
        : { orderBy?: AlamatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlamatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlamatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alamat model
   */
  readonly fields: AlamatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alamat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlamatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Alamat model
   */ 
  interface AlamatFieldRefs {
    readonly id: FieldRef<"Alamat", 'String'>
    readonly idUser: FieldRef<"Alamat", 'String'>
    readonly provinsi: FieldRef<"Alamat", 'String'>
    readonly kabupaten: FieldRef<"Alamat", 'String'>
    readonly kecamatan: FieldRef<"Alamat", 'String'>
    readonly kodepos: FieldRef<"Alamat", 'String'>
    readonly detail: FieldRef<"Alamat", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Alamat findUnique
   */
  export type AlamatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * Filter, which Alamat to fetch.
     */
    where: AlamatWhereUniqueInput
  }


  /**
   * Alamat findUniqueOrThrow
   */
  export type AlamatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * Filter, which Alamat to fetch.
     */
    where: AlamatWhereUniqueInput
  }


  /**
   * Alamat findFirst
   */
  export type AlamatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * Filter, which Alamat to fetch.
     */
    where?: AlamatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alamats to fetch.
     */
    orderBy?: AlamatOrderByWithRelationInput | AlamatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alamats.
     */
    cursor?: AlamatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alamats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alamats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alamats.
     */
    distinct?: AlamatScalarFieldEnum | AlamatScalarFieldEnum[]
  }


  /**
   * Alamat findFirstOrThrow
   */
  export type AlamatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * Filter, which Alamat to fetch.
     */
    where?: AlamatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alamats to fetch.
     */
    orderBy?: AlamatOrderByWithRelationInput | AlamatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alamats.
     */
    cursor?: AlamatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alamats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alamats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alamats.
     */
    distinct?: AlamatScalarFieldEnum | AlamatScalarFieldEnum[]
  }


  /**
   * Alamat findMany
   */
  export type AlamatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * Filter, which Alamats to fetch.
     */
    where?: AlamatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alamats to fetch.
     */
    orderBy?: AlamatOrderByWithRelationInput | AlamatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alamats.
     */
    cursor?: AlamatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alamats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alamats.
     */
    skip?: number
    distinct?: AlamatScalarFieldEnum | AlamatScalarFieldEnum[]
  }


  /**
   * Alamat create
   */
  export type AlamatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * The data needed to create a Alamat.
     */
    data: XOR<AlamatCreateInput, AlamatUncheckedCreateInput>
  }


  /**
   * Alamat createMany
   */
  export type AlamatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alamats.
     */
    data: AlamatCreateManyInput | AlamatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Alamat update
   */
  export type AlamatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * The data needed to update a Alamat.
     */
    data: XOR<AlamatUpdateInput, AlamatUncheckedUpdateInput>
    /**
     * Choose, which Alamat to update.
     */
    where: AlamatWhereUniqueInput
  }


  /**
   * Alamat updateMany
   */
  export type AlamatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alamats.
     */
    data: XOR<AlamatUpdateManyMutationInput, AlamatUncheckedUpdateManyInput>
    /**
     * Filter which Alamats to update
     */
    where?: AlamatWhereInput
  }


  /**
   * Alamat upsert
   */
  export type AlamatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * The filter to search for the Alamat to update in case it exists.
     */
    where: AlamatWhereUniqueInput
    /**
     * In case the Alamat found by the `where` argument doesn't exist, create a new Alamat with this data.
     */
    create: XOR<AlamatCreateInput, AlamatUncheckedCreateInput>
    /**
     * In case the Alamat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlamatUpdateInput, AlamatUncheckedUpdateInput>
  }


  /**
   * Alamat delete
   */
  export type AlamatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
    /**
     * Filter which Alamat to delete.
     */
    where: AlamatWhereUniqueInput
  }


  /**
   * Alamat deleteMany
   */
  export type AlamatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alamats to delete
     */
    where?: AlamatWhereInput
  }


  /**
   * Alamat without action
   */
  export type AlamatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alamat
     */
    select?: AlamatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlamatInclude<ExtArgs> | null
  }



  /**
   * Model CategoryProduct
   */

  export type AggregateCategoryProduct = {
    _count: CategoryProductCountAggregateOutputType | null
    _min: CategoryProductMinAggregateOutputType | null
    _max: CategoryProductMaxAggregateOutputType | null
  }

  export type CategoryProductMinAggregateOutputType = {
    id: string | null
    nameCategory: string | null
  }

  export type CategoryProductMaxAggregateOutputType = {
    id: string | null
    nameCategory: string | null
  }

  export type CategoryProductCountAggregateOutputType = {
    id: number
    nameCategory: number
    _all: number
  }


  export type CategoryProductMinAggregateInputType = {
    id?: true
    nameCategory?: true
  }

  export type CategoryProductMaxAggregateInputType = {
    id?: true
    nameCategory?: true
  }

  export type CategoryProductCountAggregateInputType = {
    id?: true
    nameCategory?: true
    _all?: true
  }

  export type CategoryProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryProduct to aggregate.
     */
    where?: CategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryProducts to fetch.
     */
    orderBy?: CategoryProductOrderByWithRelationInput | CategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryProducts
    **/
    _count?: true | CategoryProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryProductMaxAggregateInputType
  }

  export type GetCategoryProductAggregateType<T extends CategoryProductAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryProduct[P]>
      : GetScalarType<T[P], AggregateCategoryProduct[P]>
  }




  export type CategoryProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryProductWhereInput
    orderBy?: CategoryProductOrderByWithAggregationInput | CategoryProductOrderByWithAggregationInput[]
    by: CategoryProductScalarFieldEnum[] | CategoryProductScalarFieldEnum
    having?: CategoryProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryProductCountAggregateInputType | true
    _min?: CategoryProductMinAggregateInputType
    _max?: CategoryProductMaxAggregateInputType
  }

  export type CategoryProductGroupByOutputType = {
    id: string
    nameCategory: string
    _count: CategoryProductCountAggregateOutputType | null
    _min: CategoryProductMinAggregateOutputType | null
    _max: CategoryProductMaxAggregateOutputType | null
  }

  type GetCategoryProductGroupByPayload<T extends CategoryProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryProductGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryProductGroupByOutputType[P]>
        }
      >
    >


  export type CategoryProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameCategory?: boolean
    subCategories?: boolean | CategoryProduct$subCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryProduct"]>

  export type CategoryProductSelectScalar = {
    id?: boolean
    nameCategory?: boolean
  }

  export type CategoryProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | CategoryProduct$subCategoriesArgs<ExtArgs>
    _count?: boolean | CategoryProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryProduct"
    objects: {
      subCategories: Prisma.$SubCategoryProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nameCategory: string
    }, ExtArgs["result"]["categoryProduct"]>
    composites: {}
  }


  type CategoryProductGetPayload<S extends boolean | null | undefined | CategoryProductDefaultArgs> = $Result.GetResult<Prisma.$CategoryProductPayload, S>

  type CategoryProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryProductCountAggregateInputType | true
    }

  export interface CategoryProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryProduct'], meta: { name: 'CategoryProduct' } }
    /**
     * Find zero or one CategoryProduct that matches the filter.
     * @param {CategoryProductFindUniqueArgs} args - Arguments to find a CategoryProduct
     * @example
     * // Get one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryProductFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CategoryProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryProductFindUniqueOrThrowArgs} args - Arguments to find a CategoryProduct
     * @example
     * // Get one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CategoryProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductFindFirstArgs} args - Arguments to find a CategoryProduct
     * @example
     * // Get one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryProductFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CategoryProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductFindFirstOrThrowArgs} args - Arguments to find a CategoryProduct
     * @example
     * // Get one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CategoryProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryProducts
     * const categoryProducts = await prisma.categoryProduct.findMany()
     * 
     * // Get first 10 CategoryProducts
     * const categoryProducts = await prisma.categoryProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryProductWithIdOnly = await prisma.categoryProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CategoryProduct.
     * @param {CategoryProductCreateArgs} args - Arguments to create a CategoryProduct.
     * @example
     * // Create one CategoryProduct
     * const CategoryProduct = await prisma.categoryProduct.create({
     *   data: {
     *     // ... data to create a CategoryProduct
     *   }
     * })
     * 
    **/
    create<T extends CategoryProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryProductCreateArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CategoryProducts.
     *     @param {CategoryProductCreateManyArgs} args - Arguments to create many CategoryProducts.
     *     @example
     *     // Create many CategoryProducts
     *     const categoryProduct = await prisma.categoryProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoryProduct.
     * @param {CategoryProductDeleteArgs} args - Arguments to delete one CategoryProduct.
     * @example
     * // Delete one CategoryProduct
     * const CategoryProduct = await prisma.categoryProduct.delete({
     *   where: {
     *     // ... filter to delete one CategoryProduct
     *   }
     * })
     * 
    **/
    delete<T extends CategoryProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryProductDeleteArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CategoryProduct.
     * @param {CategoryProductUpdateArgs} args - Arguments to update one CategoryProduct.
     * @example
     * // Update one CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryProductUpdateArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CategoryProducts.
     * @param {CategoryProductDeleteManyArgs} args - Arguments to filter CategoryProducts to delete.
     * @example
     * // Delete a few CategoryProducts
     * const { count } = await prisma.categoryProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryProducts
     * const categoryProduct = await prisma.categoryProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryProduct.
     * @param {CategoryProductUpsertArgs} args - Arguments to update or create a CategoryProduct.
     * @example
     * // Update or create a CategoryProduct
     * const categoryProduct = await prisma.categoryProduct.upsert({
     *   create: {
     *     // ... data to create a CategoryProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryProduct we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryProductUpsertArgs<ExtArgs>>
    ): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductCountArgs} args - Arguments to filter CategoryProducts to count.
     * @example
     * // Count the number of CategoryProducts
     * const count = await prisma.categoryProduct.count({
     *   where: {
     *     // ... the filter for the CategoryProducts we want to count
     *   }
     * })
    **/
    count<T extends CategoryProductCountArgs>(
      args?: Subset<T, CategoryProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryProductAggregateArgs>(args: Subset<T, CategoryProductAggregateArgs>): Prisma.PrismaPromise<GetCategoryProductAggregateType<T>>

    /**
     * Group by CategoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryProductGroupByArgs['orderBy'] }
        : { orderBy?: CategoryProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryProduct model
   */
  readonly fields: CategoryProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    subCategories<T extends CategoryProduct$subCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, CategoryProduct$subCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CategoryProduct model
   */ 
  interface CategoryProductFieldRefs {
    readonly id: FieldRef<"CategoryProduct", 'String'>
    readonly nameCategory: FieldRef<"CategoryProduct", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CategoryProduct findUnique
   */
  export type CategoryProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which CategoryProduct to fetch.
     */
    where: CategoryProductWhereUniqueInput
  }


  /**
   * CategoryProduct findUniqueOrThrow
   */
  export type CategoryProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which CategoryProduct to fetch.
     */
    where: CategoryProductWhereUniqueInput
  }


  /**
   * CategoryProduct findFirst
   */
  export type CategoryProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which CategoryProduct to fetch.
     */
    where?: CategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryProducts to fetch.
     */
    orderBy?: CategoryProductOrderByWithRelationInput | CategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryProducts.
     */
    cursor?: CategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryProducts.
     */
    distinct?: CategoryProductScalarFieldEnum | CategoryProductScalarFieldEnum[]
  }


  /**
   * CategoryProduct findFirstOrThrow
   */
  export type CategoryProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which CategoryProduct to fetch.
     */
    where?: CategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryProducts to fetch.
     */
    orderBy?: CategoryProductOrderByWithRelationInput | CategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryProducts.
     */
    cursor?: CategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryProducts.
     */
    distinct?: CategoryProductScalarFieldEnum | CategoryProductScalarFieldEnum[]
  }


  /**
   * CategoryProduct findMany
   */
  export type CategoryProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which CategoryProducts to fetch.
     */
    where?: CategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryProducts to fetch.
     */
    orderBy?: CategoryProductOrderByWithRelationInput | CategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryProducts.
     */
    cursor?: CategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryProducts.
     */
    skip?: number
    distinct?: CategoryProductScalarFieldEnum | CategoryProductScalarFieldEnum[]
  }


  /**
   * CategoryProduct create
   */
  export type CategoryProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryProduct.
     */
    data: XOR<CategoryProductCreateInput, CategoryProductUncheckedCreateInput>
  }


  /**
   * CategoryProduct createMany
   */
  export type CategoryProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryProducts.
     */
    data: CategoryProductCreateManyInput | CategoryProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CategoryProduct update
   */
  export type CategoryProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryProduct.
     */
    data: XOR<CategoryProductUpdateInput, CategoryProductUncheckedUpdateInput>
    /**
     * Choose, which CategoryProduct to update.
     */
    where: CategoryProductWhereUniqueInput
  }


  /**
   * CategoryProduct updateMany
   */
  export type CategoryProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryProducts.
     */
    data: XOR<CategoryProductUpdateManyMutationInput, CategoryProductUncheckedUpdateManyInput>
    /**
     * Filter which CategoryProducts to update
     */
    where?: CategoryProductWhereInput
  }


  /**
   * CategoryProduct upsert
   */
  export type CategoryProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryProduct to update in case it exists.
     */
    where: CategoryProductWhereUniqueInput
    /**
     * In case the CategoryProduct found by the `where` argument doesn't exist, create a new CategoryProduct with this data.
     */
    create: XOR<CategoryProductCreateInput, CategoryProductUncheckedCreateInput>
    /**
     * In case the CategoryProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryProductUpdateInput, CategoryProductUncheckedUpdateInput>
  }


  /**
   * CategoryProduct delete
   */
  export type CategoryProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
    /**
     * Filter which CategoryProduct to delete.
     */
    where: CategoryProductWhereUniqueInput
  }


  /**
   * CategoryProduct deleteMany
   */
  export type CategoryProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryProducts to delete
     */
    where?: CategoryProductWhereInput
  }


  /**
   * CategoryProduct.subCategories
   */
  export type CategoryProduct$subCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    where?: SubCategoryProductWhereInput
    orderBy?: SubCategoryProductOrderByWithRelationInput | SubCategoryProductOrderByWithRelationInput[]
    cursor?: SubCategoryProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoryProductScalarFieldEnum | SubCategoryProductScalarFieldEnum[]
  }


  /**
   * CategoryProduct without action
   */
  export type CategoryProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryProduct
     */
    select?: CategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryProductInclude<ExtArgs> | null
  }



  /**
   * Model SubCategoryProduct
   */

  export type AggregateSubCategoryProduct = {
    _count: SubCategoryProductCountAggregateOutputType | null
    _min: SubCategoryProductMinAggregateOutputType | null
    _max: SubCategoryProductMaxAggregateOutputType | null
  }

  export type SubCategoryProductMinAggregateOutputType = {
    id: string | null
    nameSubCategory: string | null
    idCategory: string | null
  }

  export type SubCategoryProductMaxAggregateOutputType = {
    id: string | null
    nameSubCategory: string | null
    idCategory: string | null
  }

  export type SubCategoryProductCountAggregateOutputType = {
    id: number
    nameSubCategory: number
    idCategory: number
    _all: number
  }


  export type SubCategoryProductMinAggregateInputType = {
    id?: true
    nameSubCategory?: true
    idCategory?: true
  }

  export type SubCategoryProductMaxAggregateInputType = {
    id?: true
    nameSubCategory?: true
    idCategory?: true
  }

  export type SubCategoryProductCountAggregateInputType = {
    id?: true
    nameSubCategory?: true
    idCategory?: true
    _all?: true
  }

  export type SubCategoryProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategoryProduct to aggregate.
     */
    where?: SubCategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategoryProducts to fetch.
     */
    orderBy?: SubCategoryProductOrderByWithRelationInput | SubCategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategoryProducts
    **/
    _count?: true | SubCategoryProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryProductMaxAggregateInputType
  }

  export type GetSubCategoryProductAggregateType<T extends SubCategoryProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategoryProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategoryProduct[P]>
      : GetScalarType<T[P], AggregateSubCategoryProduct[P]>
  }




  export type SubCategoryProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryProductWhereInput
    orderBy?: SubCategoryProductOrderByWithAggregationInput | SubCategoryProductOrderByWithAggregationInput[]
    by: SubCategoryProductScalarFieldEnum[] | SubCategoryProductScalarFieldEnum
    having?: SubCategoryProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryProductCountAggregateInputType | true
    _min?: SubCategoryProductMinAggregateInputType
    _max?: SubCategoryProductMaxAggregateInputType
  }

  export type SubCategoryProductGroupByOutputType = {
    id: string
    nameSubCategory: string
    idCategory: string
    _count: SubCategoryProductCountAggregateOutputType | null
    _min: SubCategoryProductMinAggregateOutputType | null
    _max: SubCategoryProductMaxAggregateOutputType | null
  }

  type GetSubCategoryProductGroupByPayload<T extends SubCategoryProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoryProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryProductGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryProductGroupByOutputType[P]>
        }
      >
    >


  export type SubCategoryProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameSubCategory?: boolean
    idCategory?: boolean
    products?: boolean | SubCategoryProduct$productsArgs<ExtArgs>
    categoryProduct?: boolean | CategoryProductDefaultArgs<ExtArgs>
    _count?: boolean | SubCategoryProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategoryProduct"]>

  export type SubCategoryProductSelectScalar = {
    id?: boolean
    nameSubCategory?: boolean
    idCategory?: boolean
  }

  export type SubCategoryProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SubCategoryProduct$productsArgs<ExtArgs>
    categoryProduct?: boolean | CategoryProductDefaultArgs<ExtArgs>
    _count?: boolean | SubCategoryProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SubCategoryProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategoryProduct"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      categoryProduct: Prisma.$CategoryProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nameSubCategory: string
      idCategory: string
    }, ExtArgs["result"]["subCategoryProduct"]>
    composites: {}
  }


  type SubCategoryProductGetPayload<S extends boolean | null | undefined | SubCategoryProductDefaultArgs> = $Result.GetResult<Prisma.$SubCategoryProductPayload, S>

  type SubCategoryProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubCategoryProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubCategoryProductCountAggregateInputType | true
    }

  export interface SubCategoryProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategoryProduct'], meta: { name: 'SubCategoryProduct' } }
    /**
     * Find zero or one SubCategoryProduct that matches the filter.
     * @param {SubCategoryProductFindUniqueArgs} args - Arguments to find a SubCategoryProduct
     * @example
     * // Get one SubCategoryProduct
     * const subCategoryProduct = await prisma.subCategoryProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubCategoryProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoryProductFindUniqueArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SubCategoryProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubCategoryProductFindUniqueOrThrowArgs} args - Arguments to find a SubCategoryProduct
     * @example
     * // Get one SubCategoryProduct
     * const subCategoryProduct = await prisma.subCategoryProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubCategoryProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoryProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SubCategoryProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryProductFindFirstArgs} args - Arguments to find a SubCategoryProduct
     * @example
     * // Get one SubCategoryProduct
     * const subCategoryProduct = await prisma.subCategoryProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubCategoryProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoryProductFindFirstArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SubCategoryProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryProductFindFirstOrThrowArgs} args - Arguments to find a SubCategoryProduct
     * @example
     * // Get one SubCategoryProduct
     * const subCategoryProduct = await prisma.subCategoryProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubCategoryProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoryProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SubCategoryProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategoryProducts
     * const subCategoryProducts = await prisma.subCategoryProduct.findMany()
     * 
     * // Get first 10 SubCategoryProducts
     * const subCategoryProducts = await prisma.subCategoryProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryProductWithIdOnly = await prisma.subCategoryProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubCategoryProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoryProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SubCategoryProduct.
     * @param {SubCategoryProductCreateArgs} args - Arguments to create a SubCategoryProduct.
     * @example
     * // Create one SubCategoryProduct
     * const SubCategoryProduct = await prisma.subCategoryProduct.create({
     *   data: {
     *     // ... data to create a SubCategoryProduct
     *   }
     * })
     * 
    **/
    create<T extends SubCategoryProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoryProductCreateArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SubCategoryProducts.
     *     @param {SubCategoryProductCreateManyArgs} args - Arguments to create many SubCategoryProducts.
     *     @example
     *     // Create many SubCategoryProducts
     *     const subCategoryProduct = await prisma.subCategoryProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubCategoryProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoryProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategoryProduct.
     * @param {SubCategoryProductDeleteArgs} args - Arguments to delete one SubCategoryProduct.
     * @example
     * // Delete one SubCategoryProduct
     * const SubCategoryProduct = await prisma.subCategoryProduct.delete({
     *   where: {
     *     // ... filter to delete one SubCategoryProduct
     *   }
     * })
     * 
    **/
    delete<T extends SubCategoryProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoryProductDeleteArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SubCategoryProduct.
     * @param {SubCategoryProductUpdateArgs} args - Arguments to update one SubCategoryProduct.
     * @example
     * // Update one SubCategoryProduct
     * const subCategoryProduct = await prisma.subCategoryProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubCategoryProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoryProductUpdateArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SubCategoryProducts.
     * @param {SubCategoryProductDeleteManyArgs} args - Arguments to filter SubCategoryProducts to delete.
     * @example
     * // Delete a few SubCategoryProducts
     * const { count } = await prisma.subCategoryProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubCategoryProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubCategoryProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategoryProducts
     * const subCategoryProduct = await prisma.subCategoryProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubCategoryProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoryProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategoryProduct.
     * @param {SubCategoryProductUpsertArgs} args - Arguments to update or create a SubCategoryProduct.
     * @example
     * // Update or create a SubCategoryProduct
     * const subCategoryProduct = await prisma.subCategoryProduct.upsert({
     *   create: {
     *     // ... data to create a SubCategoryProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategoryProduct we want to update
     *   }
     * })
    **/
    upsert<T extends SubCategoryProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubCategoryProductUpsertArgs<ExtArgs>>
    ): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SubCategoryProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryProductCountArgs} args - Arguments to filter SubCategoryProducts to count.
     * @example
     * // Count the number of SubCategoryProducts
     * const count = await prisma.subCategoryProduct.count({
     *   where: {
     *     // ... the filter for the SubCategoryProducts we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryProductCountArgs>(
      args?: Subset<T, SubCategoryProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryProductAggregateArgs>(args: Subset<T, SubCategoryProductAggregateArgs>): Prisma.PrismaPromise<GetSubCategoryProductAggregateType<T>>

    /**
     * Group by SubCategoryProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryProductGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategoryProduct model
   */
  readonly fields: SubCategoryProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategoryProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoryProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends SubCategoryProduct$productsArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoryProduct$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    categoryProduct<T extends CategoryProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryProductDefaultArgs<ExtArgs>>): Prisma__CategoryProductClient<$Result.GetResult<Prisma.$CategoryProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SubCategoryProduct model
   */ 
  interface SubCategoryProductFieldRefs {
    readonly id: FieldRef<"SubCategoryProduct", 'String'>
    readonly nameSubCategory: FieldRef<"SubCategoryProduct", 'String'>
    readonly idCategory: FieldRef<"SubCategoryProduct", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SubCategoryProduct findUnique
   */
  export type SubCategoryProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoryProduct to fetch.
     */
    where: SubCategoryProductWhereUniqueInput
  }


  /**
   * SubCategoryProduct findUniqueOrThrow
   */
  export type SubCategoryProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoryProduct to fetch.
     */
    where: SubCategoryProductWhereUniqueInput
  }


  /**
   * SubCategoryProduct findFirst
   */
  export type SubCategoryProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoryProduct to fetch.
     */
    where?: SubCategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategoryProducts to fetch.
     */
    orderBy?: SubCategoryProductOrderByWithRelationInput | SubCategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategoryProducts.
     */
    cursor?: SubCategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategoryProducts.
     */
    distinct?: SubCategoryProductScalarFieldEnum | SubCategoryProductScalarFieldEnum[]
  }


  /**
   * SubCategoryProduct findFirstOrThrow
   */
  export type SubCategoryProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoryProduct to fetch.
     */
    where?: SubCategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategoryProducts to fetch.
     */
    orderBy?: SubCategoryProductOrderByWithRelationInput | SubCategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategoryProducts.
     */
    cursor?: SubCategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategoryProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategoryProducts.
     */
    distinct?: SubCategoryProductScalarFieldEnum | SubCategoryProductScalarFieldEnum[]
  }


  /**
   * SubCategoryProduct findMany
   */
  export type SubCategoryProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * Filter, which SubCategoryProducts to fetch.
     */
    where?: SubCategoryProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategoryProducts to fetch.
     */
    orderBy?: SubCategoryProductOrderByWithRelationInput | SubCategoryProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategoryProducts.
     */
    cursor?: SubCategoryProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategoryProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategoryProducts.
     */
    skip?: number
    distinct?: SubCategoryProductScalarFieldEnum | SubCategoryProductScalarFieldEnum[]
  }


  /**
   * SubCategoryProduct create
   */
  export type SubCategoryProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategoryProduct.
     */
    data: XOR<SubCategoryProductCreateInput, SubCategoryProductUncheckedCreateInput>
  }


  /**
   * SubCategoryProduct createMany
   */
  export type SubCategoryProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategoryProducts.
     */
    data: SubCategoryProductCreateManyInput | SubCategoryProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SubCategoryProduct update
   */
  export type SubCategoryProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategoryProduct.
     */
    data: XOR<SubCategoryProductUpdateInput, SubCategoryProductUncheckedUpdateInput>
    /**
     * Choose, which SubCategoryProduct to update.
     */
    where: SubCategoryProductWhereUniqueInput
  }


  /**
   * SubCategoryProduct updateMany
   */
  export type SubCategoryProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategoryProducts.
     */
    data: XOR<SubCategoryProductUpdateManyMutationInput, SubCategoryProductUncheckedUpdateManyInput>
    /**
     * Filter which SubCategoryProducts to update
     */
    where?: SubCategoryProductWhereInput
  }


  /**
   * SubCategoryProduct upsert
   */
  export type SubCategoryProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategoryProduct to update in case it exists.
     */
    where: SubCategoryProductWhereUniqueInput
    /**
     * In case the SubCategoryProduct found by the `where` argument doesn't exist, create a new SubCategoryProduct with this data.
     */
    create: XOR<SubCategoryProductCreateInput, SubCategoryProductUncheckedCreateInput>
    /**
     * In case the SubCategoryProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoryProductUpdateInput, SubCategoryProductUncheckedUpdateInput>
  }


  /**
   * SubCategoryProduct delete
   */
  export type SubCategoryProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
    /**
     * Filter which SubCategoryProduct to delete.
     */
    where: SubCategoryProductWhereUniqueInput
  }


  /**
   * SubCategoryProduct deleteMany
   */
  export type SubCategoryProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategoryProducts to delete
     */
    where?: SubCategoryProductWhereInput
  }


  /**
   * SubCategoryProduct.products
   */
  export type SubCategoryProduct$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * SubCategoryProduct without action
   */
  export type SubCategoryProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryProduct
     */
    select?: SubCategoryProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryProductInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    priceProduct: number | null
    discountProduct: number | null
    starProduct: number | null
  }

  export type ProductSumAggregateOutputType = {
    priceProduct: number | null
    discountProduct: number | null
    starProduct: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    idSubCategory: string | null
    nameProduct: string | null
    priceProduct: number | null
    descProduct: string | null
    discountProduct: number | null
    starProduct: number | null
    gender: string | null
    recommendedProduct: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    idSubCategory: string | null
    nameProduct: string | null
    priceProduct: number | null
    descProduct: string | null
    discountProduct: number | null
    starProduct: number | null
    gender: string | null
    recommendedProduct: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    idSubCategory: number
    nameProduct: number
    priceProduct: number
    descProduct: number
    discountProduct: number
    starProduct: number
    gender: number
    recommendedProduct: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    priceProduct?: true
    discountProduct?: true
    starProduct?: true
  }

  export type ProductSumAggregateInputType = {
    priceProduct?: true
    discountProduct?: true
    starProduct?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    idSubCategory?: true
    nameProduct?: true
    priceProduct?: true
    descProduct?: true
    discountProduct?: true
    starProduct?: true
    gender?: true
    recommendedProduct?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    idSubCategory?: true
    nameProduct?: true
    priceProduct?: true
    descProduct?: true
    discountProduct?: true
    starProduct?: true
    gender?: true
    recommendedProduct?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    idSubCategory?: true
    nameProduct?: true
    priceProduct?: true
    descProduct?: true
    discountProduct?: true
    starProduct?: true
    gender?: true
    recommendedProduct?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    idSubCategory: string
    nameProduct: string
    priceProduct: number
    descProduct: string | null
    discountProduct: number | null
    starProduct: number | null
    gender: string | null
    recommendedProduct: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idSubCategory?: boolean
    nameProduct?: boolean
    priceProduct?: boolean
    descProduct?: boolean
    discountProduct?: boolean
    starProduct?: boolean
    gender?: boolean
    recommendedProduct?: boolean
    comentsProduct?: boolean | Product$comentsProductArgs<ExtArgs>
    productDetails?: boolean | Product$productDetailsArgs<ExtArgs>
    subCategory?: boolean | SubCategoryProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    idSubCategory?: boolean
    nameProduct?: boolean
    priceProduct?: boolean
    descProduct?: boolean
    discountProduct?: boolean
    starProduct?: boolean
    gender?: boolean
    recommendedProduct?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentsProduct?: boolean | Product$comentsProductArgs<ExtArgs>
    productDetails?: boolean | Product$productDetailsArgs<ExtArgs>
    subCategory?: boolean | SubCategoryProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      comentsProduct: Prisma.$comentsProductPayload<ExtArgs>[]
      productDetails: Prisma.$ProductDetailPayload<ExtArgs>[]
      subCategory: Prisma.$SubCategoryProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idSubCategory: string
      nameProduct: string
      priceProduct: number
      descProduct: string | null
      discountProduct: number | null
      starProduct: number | null
      gender: string | null
      recommendedProduct: boolean
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    comentsProduct<T extends Product$comentsProductArgs<ExtArgs> = {}>(args?: Subset<T, Product$comentsProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    productDetails<T extends Product$productDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    subCategory<T extends SubCategoryProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubCategoryProductDefaultArgs<ExtArgs>>): Prisma__SubCategoryProductClient<$Result.GetResult<Prisma.$SubCategoryProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly idSubCategory: FieldRef<"Product", 'String'>
    readonly nameProduct: FieldRef<"Product", 'String'>
    readonly priceProduct: FieldRef<"Product", 'Float'>
    readonly descProduct: FieldRef<"Product", 'String'>
    readonly discountProduct: FieldRef<"Product", 'Float'>
    readonly starProduct: FieldRef<"Product", 'Float'>
    readonly gender: FieldRef<"Product", 'String'>
    readonly recommendedProduct: FieldRef<"Product", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.comentsProduct
   */
  export type Product$comentsProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    where?: comentsProductWhereInput
    orderBy?: comentsProductOrderByWithRelationInput | comentsProductOrderByWithRelationInput[]
    cursor?: comentsProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentsProductScalarFieldEnum | ComentsProductScalarFieldEnum[]
  }


  /**
   * Product.productDetails
   */
  export type Product$productDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    where?: ProductDetailWhereInput
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    cursor?: ProductDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }


  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model ProductDetail
   */

  export type AggregateProductDetail = {
    _count: ProductDetailCountAggregateOutputType | null
    _min: ProductDetailMinAggregateOutputType | null
    _max: ProductDetailMaxAggregateOutputType | null
  }

  export type ProductDetailMinAggregateOutputType = {
    id: string | null
    idProduct: string | null
    colorProduct: string | null
    pictureProduct: string | null
  }

  export type ProductDetailMaxAggregateOutputType = {
    id: string | null
    idProduct: string | null
    colorProduct: string | null
    pictureProduct: string | null
  }

  export type ProductDetailCountAggregateOutputType = {
    id: number
    idProduct: number
    colorProduct: number
    pictureProduct: number
    _all: number
  }


  export type ProductDetailMinAggregateInputType = {
    id?: true
    idProduct?: true
    colorProduct?: true
    pictureProduct?: true
  }

  export type ProductDetailMaxAggregateInputType = {
    id?: true
    idProduct?: true
    colorProduct?: true
    pictureProduct?: true
  }

  export type ProductDetailCountAggregateInputType = {
    id?: true
    idProduct?: true
    colorProduct?: true
    pictureProduct?: true
    _all?: true
  }

  export type ProductDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDetail to aggregate.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductDetails
    **/
    _count?: true | ProductDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductDetailMaxAggregateInputType
  }

  export type GetProductDetailAggregateType<T extends ProductDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateProductDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductDetail[P]>
      : GetScalarType<T[P], AggregateProductDetail[P]>
  }




  export type ProductDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDetailWhereInput
    orderBy?: ProductDetailOrderByWithAggregationInput | ProductDetailOrderByWithAggregationInput[]
    by: ProductDetailScalarFieldEnum[] | ProductDetailScalarFieldEnum
    having?: ProductDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductDetailCountAggregateInputType | true
    _min?: ProductDetailMinAggregateInputType
    _max?: ProductDetailMaxAggregateInputType
  }

  export type ProductDetailGroupByOutputType = {
    id: string
    idProduct: string
    colorProduct: string
    pictureProduct: string
    _count: ProductDetailCountAggregateOutputType | null
    _min: ProductDetailMinAggregateOutputType | null
    _max: ProductDetailMaxAggregateOutputType | null
  }

  type GetProductDetailGroupByPayload<T extends ProductDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ProductDetailGroupByOutputType[P]>
        }
      >
    >


  export type ProductDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProduct?: boolean
    colorProduct?: boolean
    pictureProduct?: boolean
    sizes?: boolean | ProductDetail$sizesArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productDetail"]>

  export type ProductDetailSelectScalar = {
    id?: boolean
    idProduct?: boolean
    colorProduct?: boolean
    pictureProduct?: boolean
  }

  export type ProductDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sizes?: boolean | ProductDetail$sizesArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductDetailCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductDetail"
    objects: {
      sizes: Prisma.$SizePayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idProduct: string
      colorProduct: string
      pictureProduct: string
    }, ExtArgs["result"]["productDetail"]>
    composites: {}
  }


  type ProductDetailGetPayload<S extends boolean | null | undefined | ProductDetailDefaultArgs> = $Result.GetResult<Prisma.$ProductDetailPayload, S>

  type ProductDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductDetailCountAggregateInputType | true
    }

  export interface ProductDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductDetail'], meta: { name: 'ProductDetail' } }
    /**
     * Find zero or one ProductDetail that matches the filter.
     * @param {ProductDetailFindUniqueArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductDetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProductDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductDetailFindUniqueOrThrowArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductDetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProductDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailFindFirstArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductDetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDetailFindFirstArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProductDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailFindFirstOrThrowArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductDetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProductDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductDetails
     * const productDetails = await prisma.productDetail.findMany()
     * 
     * // Get first 10 ProductDetails
     * const productDetails = await prisma.productDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productDetailWithIdOnly = await prisma.productDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductDetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProductDetail.
     * @param {ProductDetailCreateArgs} args - Arguments to create a ProductDetail.
     * @example
     * // Create one ProductDetail
     * const ProductDetail = await prisma.productDetail.create({
     *   data: {
     *     // ... data to create a ProductDetail
     *   }
     * })
     * 
    **/
    create<T extends ProductDetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDetailCreateArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProductDetails.
     *     @param {ProductDetailCreateManyArgs} args - Arguments to create many ProductDetails.
     *     @example
     *     // Create many ProductDetails
     *     const productDetail = await prisma.productDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductDetailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDetailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductDetail.
     * @param {ProductDetailDeleteArgs} args - Arguments to delete one ProductDetail.
     * @example
     * // Delete one ProductDetail
     * const ProductDetail = await prisma.productDetail.delete({
     *   where: {
     *     // ... filter to delete one ProductDetail
     *   }
     * })
     * 
    **/
    delete<T extends ProductDetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDetailDeleteArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProductDetail.
     * @param {ProductDetailUpdateArgs} args - Arguments to update one ProductDetail.
     * @example
     * // Update one ProductDetail
     * const productDetail = await prisma.productDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductDetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDetailUpdateArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProductDetails.
     * @param {ProductDetailDeleteManyArgs} args - Arguments to filter ProductDetails to delete.
     * @example
     * // Delete a few ProductDetails
     * const { count } = await prisma.productDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductDetails
     * const productDetail = await prisma.productDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductDetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductDetail.
     * @param {ProductDetailUpsertArgs} args - Arguments to update or create a ProductDetail.
     * @example
     * // Update or create a ProductDetail
     * const productDetail = await prisma.productDetail.upsert({
     *   create: {
     *     // ... data to create a ProductDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductDetail we want to update
     *   }
     * })
    **/
    upsert<T extends ProductDetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDetailUpsertArgs<ExtArgs>>
    ): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProductDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailCountArgs} args - Arguments to filter ProductDetails to count.
     * @example
     * // Count the number of ProductDetails
     * const count = await prisma.productDetail.count({
     *   where: {
     *     // ... the filter for the ProductDetails we want to count
     *   }
     * })
    **/
    count<T extends ProductDetailCountArgs>(
      args?: Subset<T, ProductDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductDetailAggregateArgs>(args: Subset<T, ProductDetailAggregateArgs>): Prisma.PrismaPromise<GetProductDetailAggregateType<T>>

    /**
     * Group by ProductDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductDetailGroupByArgs['orderBy'] }
        : { orderBy?: ProductDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductDetail model
   */
  readonly fields: ProductDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sizes<T extends ProductDetail$sizesArgs<ExtArgs> = {}>(args?: Subset<T, ProductDetail$sizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'findMany'> | Null>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProductDetail model
   */ 
  interface ProductDetailFieldRefs {
    readonly id: FieldRef<"ProductDetail", 'String'>
    readonly idProduct: FieldRef<"ProductDetail", 'String'>
    readonly colorProduct: FieldRef<"ProductDetail", 'String'>
    readonly pictureProduct: FieldRef<"ProductDetail", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ProductDetail findUnique
   */
  export type ProductDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where: ProductDetailWhereUniqueInput
  }


  /**
   * ProductDetail findUniqueOrThrow
   */
  export type ProductDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where: ProductDetailWhereUniqueInput
  }


  /**
   * ProductDetail findFirst
   */
  export type ProductDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDetails.
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDetails.
     */
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }


  /**
   * ProductDetail findFirstOrThrow
   */
  export type ProductDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDetails.
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDetails.
     */
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }


  /**
   * ProductDetail findMany
   */
  export type ProductDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetails to fetch.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductDetails.
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }


  /**
   * ProductDetail create
   */
  export type ProductDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductDetail.
     */
    data: XOR<ProductDetailCreateInput, ProductDetailUncheckedCreateInput>
  }


  /**
   * ProductDetail createMany
   */
  export type ProductDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductDetails.
     */
    data: ProductDetailCreateManyInput | ProductDetailCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProductDetail update
   */
  export type ProductDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductDetail.
     */
    data: XOR<ProductDetailUpdateInput, ProductDetailUncheckedUpdateInput>
    /**
     * Choose, which ProductDetail to update.
     */
    where: ProductDetailWhereUniqueInput
  }


  /**
   * ProductDetail updateMany
   */
  export type ProductDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductDetails.
     */
    data: XOR<ProductDetailUpdateManyMutationInput, ProductDetailUncheckedUpdateManyInput>
    /**
     * Filter which ProductDetails to update
     */
    where?: ProductDetailWhereInput
  }


  /**
   * ProductDetail upsert
   */
  export type ProductDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductDetail to update in case it exists.
     */
    where: ProductDetailWhereUniqueInput
    /**
     * In case the ProductDetail found by the `where` argument doesn't exist, create a new ProductDetail with this data.
     */
    create: XOR<ProductDetailCreateInput, ProductDetailUncheckedCreateInput>
    /**
     * In case the ProductDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductDetailUpdateInput, ProductDetailUncheckedUpdateInput>
  }


  /**
   * ProductDetail delete
   */
  export type ProductDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter which ProductDetail to delete.
     */
    where: ProductDetailWhereUniqueInput
  }


  /**
   * ProductDetail deleteMany
   */
  export type ProductDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDetails to delete
     */
    where?: ProductDetailWhereInput
  }


  /**
   * ProductDetail.sizes
   */
  export type ProductDetail$sizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    where?: SizeWhereInput
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    cursor?: SizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }


  /**
   * ProductDetail without action
   */
  export type ProductDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductDetailInclude<ExtArgs> | null
  }



  /**
   * Model Size
   */

  export type AggregateSize = {
    _count: SizeCountAggregateOutputType | null
    _avg: SizeAvgAggregateOutputType | null
    _sum: SizeSumAggregateOutputType | null
    _min: SizeMinAggregateOutputType | null
    _max: SizeMaxAggregateOutputType | null
  }

  export type SizeAvgAggregateOutputType = {
    stockProduct: number | null
  }

  export type SizeSumAggregateOutputType = {
    stockProduct: number | null
  }

  export type SizeMinAggregateOutputType = {
    id: string | null
    idProductDetail: string | null
    sizeProduct: string | null
    stockProduct: number | null
  }

  export type SizeMaxAggregateOutputType = {
    id: string | null
    idProductDetail: string | null
    sizeProduct: string | null
    stockProduct: number | null
  }

  export type SizeCountAggregateOutputType = {
    id: number
    idProductDetail: number
    sizeProduct: number
    stockProduct: number
    _all: number
  }


  export type SizeAvgAggregateInputType = {
    stockProduct?: true
  }

  export type SizeSumAggregateInputType = {
    stockProduct?: true
  }

  export type SizeMinAggregateInputType = {
    id?: true
    idProductDetail?: true
    sizeProduct?: true
    stockProduct?: true
  }

  export type SizeMaxAggregateInputType = {
    id?: true
    idProductDetail?: true
    sizeProduct?: true
    stockProduct?: true
  }

  export type SizeCountAggregateInputType = {
    id?: true
    idProductDetail?: true
    sizeProduct?: true
    stockProduct?: true
    _all?: true
  }

  export type SizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Size to aggregate.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sizes
    **/
    _count?: true | SizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SizeMaxAggregateInputType
  }

  export type GetSizeAggregateType<T extends SizeAggregateArgs> = {
        [P in keyof T & keyof AggregateSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSize[P]>
      : GetScalarType<T[P], AggregateSize[P]>
  }




  export type SizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeWhereInput
    orderBy?: SizeOrderByWithAggregationInput | SizeOrderByWithAggregationInput[]
    by: SizeScalarFieldEnum[] | SizeScalarFieldEnum
    having?: SizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SizeCountAggregateInputType | true
    _avg?: SizeAvgAggregateInputType
    _sum?: SizeSumAggregateInputType
    _min?: SizeMinAggregateInputType
    _max?: SizeMaxAggregateInputType
  }

  export type SizeGroupByOutputType = {
    id: string
    idProductDetail: string
    sizeProduct: string
    stockProduct: number
    _count: SizeCountAggregateOutputType | null
    _avg: SizeAvgAggregateOutputType | null
    _sum: SizeSumAggregateOutputType | null
    _min: SizeMinAggregateOutputType | null
    _max: SizeMaxAggregateOutputType | null
  }

  type GetSizeGroupByPayload<T extends SizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SizeGroupByOutputType[P]>
            : GetScalarType<T[P], SizeGroupByOutputType[P]>
        }
      >
    >


  export type SizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProductDetail?: boolean
    sizeProduct?: boolean
    stockProduct?: boolean
    productDetail?: boolean | ProductDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["size"]>

  export type SizeSelectScalar = {
    id?: boolean
    idProductDetail?: boolean
    sizeProduct?: boolean
    stockProduct?: boolean
  }

  export type SizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productDetail?: boolean | ProductDetailDefaultArgs<ExtArgs>
  }


  export type $SizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Size"
    objects: {
      productDetail: Prisma.$ProductDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idProductDetail: string
      sizeProduct: string
      stockProduct: number
    }, ExtArgs["result"]["size"]>
    composites: {}
  }


  type SizeGetPayload<S extends boolean | null | undefined | SizeDefaultArgs> = $Result.GetResult<Prisma.$SizePayload, S>

  type SizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SizeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SizeCountAggregateInputType | true
    }

  export interface SizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Size'], meta: { name: 'Size' } }
    /**
     * Find zero or one Size that matches the filter.
     * @param {SizeFindUniqueArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SizeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SizeFindUniqueArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Size that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SizeFindUniqueOrThrowArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SizeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SizeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Size that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindFirstArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SizeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SizeFindFirstArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Size that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindFirstOrThrowArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SizeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SizeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sizes
     * const sizes = await prisma.size.findMany()
     * 
     * // Get first 10 Sizes
     * const sizes = await prisma.size.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sizeWithIdOnly = await prisma.size.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SizeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SizeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Size.
     * @param {SizeCreateArgs} args - Arguments to create a Size.
     * @example
     * // Create one Size
     * const Size = await prisma.size.create({
     *   data: {
     *     // ... data to create a Size
     *   }
     * })
     * 
    **/
    create<T extends SizeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SizeCreateArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sizes.
     *     @param {SizeCreateManyArgs} args - Arguments to create many Sizes.
     *     @example
     *     // Create many Sizes
     *     const size = await prisma.size.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SizeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SizeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Size.
     * @param {SizeDeleteArgs} args - Arguments to delete one Size.
     * @example
     * // Delete one Size
     * const Size = await prisma.size.delete({
     *   where: {
     *     // ... filter to delete one Size
     *   }
     * })
     * 
    **/
    delete<T extends SizeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SizeDeleteArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Size.
     * @param {SizeUpdateArgs} args - Arguments to update one Size.
     * @example
     * // Update one Size
     * const size = await prisma.size.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SizeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SizeUpdateArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sizes.
     * @param {SizeDeleteManyArgs} args - Arguments to filter Sizes to delete.
     * @example
     * // Delete a few Sizes
     * const { count } = await prisma.size.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SizeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SizeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sizes
     * const size = await prisma.size.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SizeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SizeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Size.
     * @param {SizeUpsertArgs} args - Arguments to update or create a Size.
     * @example
     * // Update or create a Size
     * const size = await prisma.size.upsert({
     *   create: {
     *     // ... data to create a Size
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Size we want to update
     *   }
     * })
    **/
    upsert<T extends SizeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SizeUpsertArgs<ExtArgs>>
    ): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCountArgs} args - Arguments to filter Sizes to count.
     * @example
     * // Count the number of Sizes
     * const count = await prisma.size.count({
     *   where: {
     *     // ... the filter for the Sizes we want to count
     *   }
     * })
    **/
    count<T extends SizeCountArgs>(
      args?: Subset<T, SizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Size.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SizeAggregateArgs>(args: Subset<T, SizeAggregateArgs>): Prisma.PrismaPromise<GetSizeAggregateType<T>>

    /**
     * Group by Size.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SizeGroupByArgs['orderBy'] }
        : { orderBy?: SizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Size model
   */
  readonly fields: SizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Size.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    productDetail<T extends ProductDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDetailDefaultArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Size model
   */ 
  interface SizeFieldRefs {
    readonly id: FieldRef<"Size", 'String'>
    readonly idProductDetail: FieldRef<"Size", 'String'>
    readonly sizeProduct: FieldRef<"Size", 'String'>
    readonly stockProduct: FieldRef<"Size", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Size findUnique
   */
  export type SizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where: SizeWhereUniqueInput
  }


  /**
   * Size findUniqueOrThrow
   */
  export type SizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where: SizeWhereUniqueInput
  }


  /**
   * Size findFirst
   */
  export type SizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sizes.
     */
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }


  /**
   * Size findFirstOrThrow
   */
  export type SizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sizes.
     */
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }


  /**
   * Size findMany
   */
  export type SizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Sizes to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }


  /**
   * Size create
   */
  export type SizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The data needed to create a Size.
     */
    data: XOR<SizeCreateInput, SizeUncheckedCreateInput>
  }


  /**
   * Size createMany
   */
  export type SizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sizes.
     */
    data: SizeCreateManyInput | SizeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Size update
   */
  export type SizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The data needed to update a Size.
     */
    data: XOR<SizeUpdateInput, SizeUncheckedUpdateInput>
    /**
     * Choose, which Size to update.
     */
    where: SizeWhereUniqueInput
  }


  /**
   * Size updateMany
   */
  export type SizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sizes.
     */
    data: XOR<SizeUpdateManyMutationInput, SizeUncheckedUpdateManyInput>
    /**
     * Filter which Sizes to update
     */
    where?: SizeWhereInput
  }


  /**
   * Size upsert
   */
  export type SizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The filter to search for the Size to update in case it exists.
     */
    where: SizeWhereUniqueInput
    /**
     * In case the Size found by the `where` argument doesn't exist, create a new Size with this data.
     */
    create: XOR<SizeCreateInput, SizeUncheckedCreateInput>
    /**
     * In case the Size was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SizeUpdateInput, SizeUncheckedUpdateInput>
  }


  /**
   * Size delete
   */
  export type SizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter which Size to delete.
     */
    where: SizeWhereUniqueInput
  }


  /**
   * Size deleteMany
   */
  export type SizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sizes to delete
     */
    where?: SizeWhereInput
  }


  /**
   * Size without action
   */
  export type SizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SizeInclude<ExtArgs> | null
  }



  /**
   * Model comentsProduct
   */

  export type AggregateComentsProduct = {
    _count: ComentsProductCountAggregateOutputType | null
    _avg: ComentsProductAvgAggregateOutputType | null
    _sum: ComentsProductSumAggregateOutputType | null
    _min: ComentsProductMinAggregateOutputType | null
    _max: ComentsProductMaxAggregateOutputType | null
  }

  export type ComentsProductAvgAggregateOutputType = {
    rating: number | null
  }

  export type ComentsProductSumAggregateOutputType = {
    rating: number | null
  }

  export type ComentsProductMinAggregateOutputType = {
    id: string | null
    idProduct: string | null
    idUser: string | null
    comment: string | null
    rating: number | null
    created_at: Date | null
  }

  export type ComentsProductMaxAggregateOutputType = {
    id: string | null
    idProduct: string | null
    idUser: string | null
    comment: string | null
    rating: number | null
    created_at: Date | null
  }

  export type ComentsProductCountAggregateOutputType = {
    id: number
    idProduct: number
    idUser: number
    comment: number
    rating: number
    created_at: number
    _all: number
  }


  export type ComentsProductAvgAggregateInputType = {
    rating?: true
  }

  export type ComentsProductSumAggregateInputType = {
    rating?: true
  }

  export type ComentsProductMinAggregateInputType = {
    id?: true
    idProduct?: true
    idUser?: true
    comment?: true
    rating?: true
    created_at?: true
  }

  export type ComentsProductMaxAggregateInputType = {
    id?: true
    idProduct?: true
    idUser?: true
    comment?: true
    rating?: true
    created_at?: true
  }

  export type ComentsProductCountAggregateInputType = {
    id?: true
    idProduct?: true
    idUser?: true
    comment?: true
    rating?: true
    created_at?: true
    _all?: true
  }

  export type ComentsProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentsProduct to aggregate.
     */
    where?: comentsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentsProducts to fetch.
     */
    orderBy?: comentsProductOrderByWithRelationInput | comentsProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comentsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentsProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comentsProducts
    **/
    _count?: true | ComentsProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentsProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentsProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentsProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentsProductMaxAggregateInputType
  }

  export type GetComentsProductAggregateType<T extends ComentsProductAggregateArgs> = {
        [P in keyof T & keyof AggregateComentsProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentsProduct[P]>
      : GetScalarType<T[P], AggregateComentsProduct[P]>
  }




  export type comentsProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentsProductWhereInput
    orderBy?: comentsProductOrderByWithAggregationInput | comentsProductOrderByWithAggregationInput[]
    by: ComentsProductScalarFieldEnum[] | ComentsProductScalarFieldEnum
    having?: comentsProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentsProductCountAggregateInputType | true
    _avg?: ComentsProductAvgAggregateInputType
    _sum?: ComentsProductSumAggregateInputType
    _min?: ComentsProductMinAggregateInputType
    _max?: ComentsProductMaxAggregateInputType
  }

  export type ComentsProductGroupByOutputType = {
    id: string
    idProduct: string
    idUser: string
    comment: string
    rating: number
    created_at: Date
    _count: ComentsProductCountAggregateOutputType | null
    _avg: ComentsProductAvgAggregateOutputType | null
    _sum: ComentsProductSumAggregateOutputType | null
    _min: ComentsProductMinAggregateOutputType | null
    _max: ComentsProductMaxAggregateOutputType | null
  }

  type GetComentsProductGroupByPayload<T extends comentsProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentsProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentsProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentsProductGroupByOutputType[P]>
            : GetScalarType<T[P], ComentsProductGroupByOutputType[P]>
        }
      >
    >


  export type comentsProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idProduct?: boolean
    idUser?: boolean
    comment?: boolean
    rating?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentsProduct"]>

  export type comentsProductSelectScalar = {
    id?: boolean
    idProduct?: boolean
    idUser?: boolean
    comment?: boolean
    rating?: boolean
    created_at?: boolean
  }

  export type comentsProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }


  export type $comentsProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comentsProduct"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idProduct: string
      idUser: string
      comment: string
      rating: number
      created_at: Date
    }, ExtArgs["result"]["comentsProduct"]>
    composites: {}
  }


  type comentsProductGetPayload<S extends boolean | null | undefined | comentsProductDefaultArgs> = $Result.GetResult<Prisma.$comentsProductPayload, S>

  type comentsProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comentsProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentsProductCountAggregateInputType | true
    }

  export interface comentsProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comentsProduct'], meta: { name: 'comentsProduct' } }
    /**
     * Find zero or one ComentsProduct that matches the filter.
     * @param {comentsProductFindUniqueArgs} args - Arguments to find a ComentsProduct
     * @example
     * // Get one ComentsProduct
     * const comentsProduct = await prisma.comentsProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comentsProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, comentsProductFindUniqueArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ComentsProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comentsProductFindUniqueOrThrowArgs} args - Arguments to find a ComentsProduct
     * @example
     * // Get one ComentsProduct
     * const comentsProduct = await prisma.comentsProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comentsProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comentsProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ComentsProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentsProductFindFirstArgs} args - Arguments to find a ComentsProduct
     * @example
     * // Get one ComentsProduct
     * const comentsProduct = await prisma.comentsProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comentsProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, comentsProductFindFirstArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ComentsProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentsProductFindFirstOrThrowArgs} args - Arguments to find a ComentsProduct
     * @example
     * // Get one ComentsProduct
     * const comentsProduct = await prisma.comentsProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comentsProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comentsProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ComentsProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentsProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComentsProducts
     * const comentsProducts = await prisma.comentsProduct.findMany()
     * 
     * // Get first 10 ComentsProducts
     * const comentsProducts = await prisma.comentsProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comentsProductWithIdOnly = await prisma.comentsProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends comentsProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comentsProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ComentsProduct.
     * @param {comentsProductCreateArgs} args - Arguments to create a ComentsProduct.
     * @example
     * // Create one ComentsProduct
     * const ComentsProduct = await prisma.comentsProduct.create({
     *   data: {
     *     // ... data to create a ComentsProduct
     *   }
     * })
     * 
    **/
    create<T extends comentsProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, comentsProductCreateArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ComentsProducts.
     *     @param {comentsProductCreateManyArgs} args - Arguments to create many ComentsProducts.
     *     @example
     *     // Create many ComentsProducts
     *     const comentsProduct = await prisma.comentsProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comentsProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comentsProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ComentsProduct.
     * @param {comentsProductDeleteArgs} args - Arguments to delete one ComentsProduct.
     * @example
     * // Delete one ComentsProduct
     * const ComentsProduct = await prisma.comentsProduct.delete({
     *   where: {
     *     // ... filter to delete one ComentsProduct
     *   }
     * })
     * 
    **/
    delete<T extends comentsProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, comentsProductDeleteArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ComentsProduct.
     * @param {comentsProductUpdateArgs} args - Arguments to update one ComentsProduct.
     * @example
     * // Update one ComentsProduct
     * const comentsProduct = await prisma.comentsProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comentsProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, comentsProductUpdateArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ComentsProducts.
     * @param {comentsProductDeleteManyArgs} args - Arguments to filter ComentsProducts to delete.
     * @example
     * // Delete a few ComentsProducts
     * const { count } = await prisma.comentsProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comentsProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comentsProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComentsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentsProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComentsProducts
     * const comentsProduct = await prisma.comentsProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comentsProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, comentsProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComentsProduct.
     * @param {comentsProductUpsertArgs} args - Arguments to update or create a ComentsProduct.
     * @example
     * // Update or create a ComentsProduct
     * const comentsProduct = await prisma.comentsProduct.upsert({
     *   create: {
     *     // ... data to create a ComentsProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComentsProduct we want to update
     *   }
     * })
    **/
    upsert<T extends comentsProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, comentsProductUpsertArgs<ExtArgs>>
    ): Prisma__comentsProductClient<$Result.GetResult<Prisma.$comentsProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ComentsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentsProductCountArgs} args - Arguments to filter ComentsProducts to count.
     * @example
     * // Count the number of ComentsProducts
     * const count = await prisma.comentsProduct.count({
     *   where: {
     *     // ... the filter for the ComentsProducts we want to count
     *   }
     * })
    **/
    count<T extends comentsProductCountArgs>(
      args?: Subset<T, comentsProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentsProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComentsProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentsProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentsProductAggregateArgs>(args: Subset<T, ComentsProductAggregateArgs>): Prisma.PrismaPromise<GetComentsProductAggregateType<T>>

    /**
     * Group by ComentsProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentsProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comentsProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comentsProductGroupByArgs['orderBy'] }
        : { orderBy?: comentsProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comentsProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentsProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comentsProduct model
   */
  readonly fields: comentsProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comentsProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comentsProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the comentsProduct model
   */ 
  interface comentsProductFieldRefs {
    readonly id: FieldRef<"comentsProduct", 'String'>
    readonly idProduct: FieldRef<"comentsProduct", 'String'>
    readonly idUser: FieldRef<"comentsProduct", 'String'>
    readonly comment: FieldRef<"comentsProduct", 'String'>
    readonly rating: FieldRef<"comentsProduct", 'Float'>
    readonly created_at: FieldRef<"comentsProduct", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * comentsProduct findUnique
   */
  export type comentsProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * Filter, which comentsProduct to fetch.
     */
    where: comentsProductWhereUniqueInput
  }


  /**
   * comentsProduct findUniqueOrThrow
   */
  export type comentsProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * Filter, which comentsProduct to fetch.
     */
    where: comentsProductWhereUniqueInput
  }


  /**
   * comentsProduct findFirst
   */
  export type comentsProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * Filter, which comentsProduct to fetch.
     */
    where?: comentsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentsProducts to fetch.
     */
    orderBy?: comentsProductOrderByWithRelationInput | comentsProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentsProducts.
     */
    cursor?: comentsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentsProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentsProducts.
     */
    distinct?: ComentsProductScalarFieldEnum | ComentsProductScalarFieldEnum[]
  }


  /**
   * comentsProduct findFirstOrThrow
   */
  export type comentsProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * Filter, which comentsProduct to fetch.
     */
    where?: comentsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentsProducts to fetch.
     */
    orderBy?: comentsProductOrderByWithRelationInput | comentsProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentsProducts.
     */
    cursor?: comentsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentsProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentsProducts.
     */
    distinct?: ComentsProductScalarFieldEnum | ComentsProductScalarFieldEnum[]
  }


  /**
   * comentsProduct findMany
   */
  export type comentsProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * Filter, which comentsProducts to fetch.
     */
    where?: comentsProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentsProducts to fetch.
     */
    orderBy?: comentsProductOrderByWithRelationInput | comentsProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comentsProducts.
     */
    cursor?: comentsProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentsProducts.
     */
    skip?: number
    distinct?: ComentsProductScalarFieldEnum | ComentsProductScalarFieldEnum[]
  }


  /**
   * comentsProduct create
   */
  export type comentsProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * The data needed to create a comentsProduct.
     */
    data: XOR<comentsProductCreateInput, comentsProductUncheckedCreateInput>
  }


  /**
   * comentsProduct createMany
   */
  export type comentsProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comentsProducts.
     */
    data: comentsProductCreateManyInput | comentsProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * comentsProduct update
   */
  export type comentsProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * The data needed to update a comentsProduct.
     */
    data: XOR<comentsProductUpdateInput, comentsProductUncheckedUpdateInput>
    /**
     * Choose, which comentsProduct to update.
     */
    where: comentsProductWhereUniqueInput
  }


  /**
   * comentsProduct updateMany
   */
  export type comentsProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comentsProducts.
     */
    data: XOR<comentsProductUpdateManyMutationInput, comentsProductUncheckedUpdateManyInput>
    /**
     * Filter which comentsProducts to update
     */
    where?: comentsProductWhereInput
  }


  /**
   * comentsProduct upsert
   */
  export type comentsProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * The filter to search for the comentsProduct to update in case it exists.
     */
    where: comentsProductWhereUniqueInput
    /**
     * In case the comentsProduct found by the `where` argument doesn't exist, create a new comentsProduct with this data.
     */
    create: XOR<comentsProductCreateInput, comentsProductUncheckedCreateInput>
    /**
     * In case the comentsProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comentsProductUpdateInput, comentsProductUncheckedUpdateInput>
  }


  /**
   * comentsProduct delete
   */
  export type comentsProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
    /**
     * Filter which comentsProduct to delete.
     */
    where: comentsProductWhereUniqueInput
  }


  /**
   * comentsProduct deleteMany
   */
  export type comentsProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentsProducts to delete
     */
    where?: comentsProductWhereInput
  }


  /**
   * comentsProduct without action
   */
  export type comentsProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentsProduct
     */
    select?: comentsProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comentsProductInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    phoneNumber: 'phoneNumber',
    profilePic: 'profilePic',
    superUser: 'superUser'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AlamatScalarFieldEnum: {
    id: 'id',
    idUser: 'idUser',
    provinsi: 'provinsi',
    kabupaten: 'kabupaten',
    kecamatan: 'kecamatan',
    kodepos: 'kodepos',
    detail: 'detail'
  };

  export type AlamatScalarFieldEnum = (typeof AlamatScalarFieldEnum)[keyof typeof AlamatScalarFieldEnum]


  export const CategoryProductScalarFieldEnum: {
    id: 'id',
    nameCategory: 'nameCategory'
  };

  export type CategoryProductScalarFieldEnum = (typeof CategoryProductScalarFieldEnum)[keyof typeof CategoryProductScalarFieldEnum]


  export const SubCategoryProductScalarFieldEnum: {
    id: 'id',
    nameSubCategory: 'nameSubCategory',
    idCategory: 'idCategory'
  };

  export type SubCategoryProductScalarFieldEnum = (typeof SubCategoryProductScalarFieldEnum)[keyof typeof SubCategoryProductScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    idSubCategory: 'idSubCategory',
    nameProduct: 'nameProduct',
    priceProduct: 'priceProduct',
    descProduct: 'descProduct',
    discountProduct: 'discountProduct',
    starProduct: 'starProduct',
    gender: 'gender',
    recommendedProduct: 'recommendedProduct'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductDetailScalarFieldEnum: {
    id: 'id',
    idProduct: 'idProduct',
    colorProduct: 'colorProduct',
    pictureProduct: 'pictureProduct'
  };

  export type ProductDetailScalarFieldEnum = (typeof ProductDetailScalarFieldEnum)[keyof typeof ProductDetailScalarFieldEnum]


  export const SizeScalarFieldEnum: {
    id: 'id',
    idProductDetail: 'idProductDetail',
    sizeProduct: 'sizeProduct',
    stockProduct: 'stockProduct'
  };

  export type SizeScalarFieldEnum = (typeof SizeScalarFieldEnum)[keyof typeof SizeScalarFieldEnum]


  export const ComentsProductScalarFieldEnum: {
    id: 'id',
    idProduct: 'idProduct',
    idUser: 'idUser',
    comment: 'comment',
    rating: 'rating',
    created_at: 'created_at'
  };

  export type ComentsProductScalarFieldEnum = (typeof ComentsProductScalarFieldEnum)[keyof typeof ComentsProductScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    profilePic?: StringNullableFilter<"User"> | string | null
    superUser?: BoolFilter<"User"> | boolean
    alamat?: XOR<AlamatNullableRelationFilter, AlamatWhereInput> | null
    comentsUser?: ComentsProductListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    profilePic?: SortOrderInput | SortOrder
    superUser?: SortOrder
    alamat?: AlamatOrderByWithRelationInput
    comentsUser?: comentsProductOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    profilePic?: StringNullableFilter<"User"> | string | null
    superUser?: BoolFilter<"User"> | boolean
    alamat?: XOR<AlamatNullableRelationFilter, AlamatWhereInput> | null
    comentsUser?: ComentsProductListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    profilePic?: SortOrderInput | SortOrder
    superUser?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePic?: StringNullableWithAggregatesFilter<"User"> | string | null
    superUser?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AlamatWhereInput = {
    AND?: AlamatWhereInput | AlamatWhereInput[]
    OR?: AlamatWhereInput[]
    NOT?: AlamatWhereInput | AlamatWhereInput[]
    id?: StringFilter<"Alamat"> | string
    idUser?: StringFilter<"Alamat"> | string
    provinsi?: StringFilter<"Alamat"> | string
    kabupaten?: StringFilter<"Alamat"> | string
    kecamatan?: StringFilter<"Alamat"> | string
    kodepos?: StringFilter<"Alamat"> | string
    detail?: StringFilter<"Alamat"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AlamatOrderByWithRelationInput = {
    id?: SortOrder
    idUser?: SortOrder
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kodepos?: SortOrder
    detail?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AlamatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idUser?: string
    AND?: AlamatWhereInput | AlamatWhereInput[]
    OR?: AlamatWhereInput[]
    NOT?: AlamatWhereInput | AlamatWhereInput[]
    provinsi?: StringFilter<"Alamat"> | string
    kabupaten?: StringFilter<"Alamat"> | string
    kecamatan?: StringFilter<"Alamat"> | string
    kodepos?: StringFilter<"Alamat"> | string
    detail?: StringFilter<"Alamat"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "idUser">

  export type AlamatOrderByWithAggregationInput = {
    id?: SortOrder
    idUser?: SortOrder
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kodepos?: SortOrder
    detail?: SortOrder
    _count?: AlamatCountOrderByAggregateInput
    _max?: AlamatMaxOrderByAggregateInput
    _min?: AlamatMinOrderByAggregateInput
  }

  export type AlamatScalarWhereWithAggregatesInput = {
    AND?: AlamatScalarWhereWithAggregatesInput | AlamatScalarWhereWithAggregatesInput[]
    OR?: AlamatScalarWhereWithAggregatesInput[]
    NOT?: AlamatScalarWhereWithAggregatesInput | AlamatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alamat"> | string
    idUser?: StringWithAggregatesFilter<"Alamat"> | string
    provinsi?: StringWithAggregatesFilter<"Alamat"> | string
    kabupaten?: StringWithAggregatesFilter<"Alamat"> | string
    kecamatan?: StringWithAggregatesFilter<"Alamat"> | string
    kodepos?: StringWithAggregatesFilter<"Alamat"> | string
    detail?: StringWithAggregatesFilter<"Alamat"> | string
  }

  export type CategoryProductWhereInput = {
    AND?: CategoryProductWhereInput | CategoryProductWhereInput[]
    OR?: CategoryProductWhereInput[]
    NOT?: CategoryProductWhereInput | CategoryProductWhereInput[]
    id?: StringFilter<"CategoryProduct"> | string
    nameCategory?: StringFilter<"CategoryProduct"> | string
    subCategories?: SubCategoryProductListRelationFilter
  }

  export type CategoryProductOrderByWithRelationInput = {
    id?: SortOrder
    nameCategory?: SortOrder
    subCategories?: SubCategoryProductOrderByRelationAggregateInput
  }

  export type CategoryProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryProductWhereInput | CategoryProductWhereInput[]
    OR?: CategoryProductWhereInput[]
    NOT?: CategoryProductWhereInput | CategoryProductWhereInput[]
    nameCategory?: StringFilter<"CategoryProduct"> | string
    subCategories?: SubCategoryProductListRelationFilter
  }, "id">

  export type CategoryProductOrderByWithAggregationInput = {
    id?: SortOrder
    nameCategory?: SortOrder
    _count?: CategoryProductCountOrderByAggregateInput
    _max?: CategoryProductMaxOrderByAggregateInput
    _min?: CategoryProductMinOrderByAggregateInput
  }

  export type CategoryProductScalarWhereWithAggregatesInput = {
    AND?: CategoryProductScalarWhereWithAggregatesInput | CategoryProductScalarWhereWithAggregatesInput[]
    OR?: CategoryProductScalarWhereWithAggregatesInput[]
    NOT?: CategoryProductScalarWhereWithAggregatesInput | CategoryProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryProduct"> | string
    nameCategory?: StringWithAggregatesFilter<"CategoryProduct"> | string
  }

  export type SubCategoryProductWhereInput = {
    AND?: SubCategoryProductWhereInput | SubCategoryProductWhereInput[]
    OR?: SubCategoryProductWhereInput[]
    NOT?: SubCategoryProductWhereInput | SubCategoryProductWhereInput[]
    id?: StringFilter<"SubCategoryProduct"> | string
    nameSubCategory?: StringFilter<"SubCategoryProduct"> | string
    idCategory?: StringFilter<"SubCategoryProduct"> | string
    products?: ProductListRelationFilter
    categoryProduct?: XOR<CategoryProductRelationFilter, CategoryProductWhereInput>
  }

  export type SubCategoryProductOrderByWithRelationInput = {
    id?: SortOrder
    nameSubCategory?: SortOrder
    idCategory?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    categoryProduct?: CategoryProductOrderByWithRelationInput
  }

  export type SubCategoryProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubCategoryProductWhereInput | SubCategoryProductWhereInput[]
    OR?: SubCategoryProductWhereInput[]
    NOT?: SubCategoryProductWhereInput | SubCategoryProductWhereInput[]
    nameSubCategory?: StringFilter<"SubCategoryProduct"> | string
    idCategory?: StringFilter<"SubCategoryProduct"> | string
    products?: ProductListRelationFilter
    categoryProduct?: XOR<CategoryProductRelationFilter, CategoryProductWhereInput>
  }, "id">

  export type SubCategoryProductOrderByWithAggregationInput = {
    id?: SortOrder
    nameSubCategory?: SortOrder
    idCategory?: SortOrder
    _count?: SubCategoryProductCountOrderByAggregateInput
    _max?: SubCategoryProductMaxOrderByAggregateInput
    _min?: SubCategoryProductMinOrderByAggregateInput
  }

  export type SubCategoryProductScalarWhereWithAggregatesInput = {
    AND?: SubCategoryProductScalarWhereWithAggregatesInput | SubCategoryProductScalarWhereWithAggregatesInput[]
    OR?: SubCategoryProductScalarWhereWithAggregatesInput[]
    NOT?: SubCategoryProductScalarWhereWithAggregatesInput | SubCategoryProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubCategoryProduct"> | string
    nameSubCategory?: StringWithAggregatesFilter<"SubCategoryProduct"> | string
    idCategory?: StringWithAggregatesFilter<"SubCategoryProduct"> | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    idSubCategory?: StringFilter<"Product"> | string
    nameProduct?: StringFilter<"Product"> | string
    priceProduct?: FloatFilter<"Product"> | number
    descProduct?: StringNullableFilter<"Product"> | string | null
    discountProduct?: FloatNullableFilter<"Product"> | number | null
    starProduct?: FloatNullableFilter<"Product"> | number | null
    gender?: StringNullableFilter<"Product"> | string | null
    recommendedProduct?: BoolFilter<"Product"> | boolean
    comentsProduct?: ComentsProductListRelationFilter
    productDetails?: ProductDetailListRelationFilter
    subCategory?: XOR<SubCategoryProductRelationFilter, SubCategoryProductWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    idSubCategory?: SortOrder
    nameProduct?: SortOrder
    priceProduct?: SortOrder
    descProduct?: SortOrderInput | SortOrder
    discountProduct?: SortOrderInput | SortOrder
    starProduct?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    recommendedProduct?: SortOrder
    comentsProduct?: comentsProductOrderByRelationAggregateInput
    productDetails?: ProductDetailOrderByRelationAggregateInput
    subCategory?: SubCategoryProductOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    idSubCategory?: StringFilter<"Product"> | string
    nameProduct?: StringFilter<"Product"> | string
    priceProduct?: FloatFilter<"Product"> | number
    descProduct?: StringNullableFilter<"Product"> | string | null
    discountProduct?: FloatNullableFilter<"Product"> | number | null
    starProduct?: FloatNullableFilter<"Product"> | number | null
    gender?: StringNullableFilter<"Product"> | string | null
    recommendedProduct?: BoolFilter<"Product"> | boolean
    comentsProduct?: ComentsProductListRelationFilter
    productDetails?: ProductDetailListRelationFilter
    subCategory?: XOR<SubCategoryProductRelationFilter, SubCategoryProductWhereInput>
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    idSubCategory?: SortOrder
    nameProduct?: SortOrder
    priceProduct?: SortOrder
    descProduct?: SortOrderInput | SortOrder
    discountProduct?: SortOrderInput | SortOrder
    starProduct?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    recommendedProduct?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    idSubCategory?: StringWithAggregatesFilter<"Product"> | string
    nameProduct?: StringWithAggregatesFilter<"Product"> | string
    priceProduct?: FloatWithAggregatesFilter<"Product"> | number
    descProduct?: StringNullableWithAggregatesFilter<"Product"> | string | null
    discountProduct?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    starProduct?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    gender?: StringNullableWithAggregatesFilter<"Product"> | string | null
    recommendedProduct?: BoolWithAggregatesFilter<"Product"> | boolean
  }

  export type ProductDetailWhereInput = {
    AND?: ProductDetailWhereInput | ProductDetailWhereInput[]
    OR?: ProductDetailWhereInput[]
    NOT?: ProductDetailWhereInput | ProductDetailWhereInput[]
    id?: StringFilter<"ProductDetail"> | string
    idProduct?: StringFilter<"ProductDetail"> | string
    colorProduct?: StringFilter<"ProductDetail"> | string
    pictureProduct?: StringFilter<"ProductDetail"> | string
    sizes?: SizeListRelationFilter
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductDetailOrderByWithRelationInput = {
    id?: SortOrder
    idProduct?: SortOrder
    colorProduct?: SortOrder
    pictureProduct?: SortOrder
    sizes?: SizeOrderByRelationAggregateInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductDetailWhereInput | ProductDetailWhereInput[]
    OR?: ProductDetailWhereInput[]
    NOT?: ProductDetailWhereInput | ProductDetailWhereInput[]
    idProduct?: StringFilter<"ProductDetail"> | string
    colorProduct?: StringFilter<"ProductDetail"> | string
    pictureProduct?: StringFilter<"ProductDetail"> | string
    sizes?: SizeListRelationFilter
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductDetailOrderByWithAggregationInput = {
    id?: SortOrder
    idProduct?: SortOrder
    colorProduct?: SortOrder
    pictureProduct?: SortOrder
    _count?: ProductDetailCountOrderByAggregateInput
    _max?: ProductDetailMaxOrderByAggregateInput
    _min?: ProductDetailMinOrderByAggregateInput
  }

  export type ProductDetailScalarWhereWithAggregatesInput = {
    AND?: ProductDetailScalarWhereWithAggregatesInput | ProductDetailScalarWhereWithAggregatesInput[]
    OR?: ProductDetailScalarWhereWithAggregatesInput[]
    NOT?: ProductDetailScalarWhereWithAggregatesInput | ProductDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductDetail"> | string
    idProduct?: StringWithAggregatesFilter<"ProductDetail"> | string
    colorProduct?: StringWithAggregatesFilter<"ProductDetail"> | string
    pictureProduct?: StringWithAggregatesFilter<"ProductDetail"> | string
  }

  export type SizeWhereInput = {
    AND?: SizeWhereInput | SizeWhereInput[]
    OR?: SizeWhereInput[]
    NOT?: SizeWhereInput | SizeWhereInput[]
    id?: StringFilter<"Size"> | string
    idProductDetail?: StringFilter<"Size"> | string
    sizeProduct?: StringFilter<"Size"> | string
    stockProduct?: IntFilter<"Size"> | number
    productDetail?: XOR<ProductDetailRelationFilter, ProductDetailWhereInput>
  }

  export type SizeOrderByWithRelationInput = {
    id?: SortOrder
    idProductDetail?: SortOrder
    sizeProduct?: SortOrder
    stockProduct?: SortOrder
    productDetail?: ProductDetailOrderByWithRelationInput
  }

  export type SizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SizeWhereInput | SizeWhereInput[]
    OR?: SizeWhereInput[]
    NOT?: SizeWhereInput | SizeWhereInput[]
    idProductDetail?: StringFilter<"Size"> | string
    sizeProduct?: StringFilter<"Size"> | string
    stockProduct?: IntFilter<"Size"> | number
    productDetail?: XOR<ProductDetailRelationFilter, ProductDetailWhereInput>
  }, "id">

  export type SizeOrderByWithAggregationInput = {
    id?: SortOrder
    idProductDetail?: SortOrder
    sizeProduct?: SortOrder
    stockProduct?: SortOrder
    _count?: SizeCountOrderByAggregateInput
    _avg?: SizeAvgOrderByAggregateInput
    _max?: SizeMaxOrderByAggregateInput
    _min?: SizeMinOrderByAggregateInput
    _sum?: SizeSumOrderByAggregateInput
  }

  export type SizeScalarWhereWithAggregatesInput = {
    AND?: SizeScalarWhereWithAggregatesInput | SizeScalarWhereWithAggregatesInput[]
    OR?: SizeScalarWhereWithAggregatesInput[]
    NOT?: SizeScalarWhereWithAggregatesInput | SizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Size"> | string
    idProductDetail?: StringWithAggregatesFilter<"Size"> | string
    sizeProduct?: StringWithAggregatesFilter<"Size"> | string
    stockProduct?: IntWithAggregatesFilter<"Size"> | number
  }

  export type comentsProductWhereInput = {
    AND?: comentsProductWhereInput | comentsProductWhereInput[]
    OR?: comentsProductWhereInput[]
    NOT?: comentsProductWhereInput | comentsProductWhereInput[]
    id?: StringFilter<"comentsProduct"> | string
    idProduct?: StringFilter<"comentsProduct"> | string
    idUser?: StringFilter<"comentsProduct"> | string
    comment?: StringFilter<"comentsProduct"> | string
    rating?: FloatFilter<"comentsProduct"> | number
    created_at?: DateTimeFilter<"comentsProduct"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type comentsProductOrderByWithRelationInput = {
    id?: SortOrder
    idProduct?: SortOrder
    idUser?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type comentsProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: comentsProductWhereInput | comentsProductWhereInput[]
    OR?: comentsProductWhereInput[]
    NOT?: comentsProductWhereInput | comentsProductWhereInput[]
    idProduct?: StringFilter<"comentsProduct"> | string
    idUser?: StringFilter<"comentsProduct"> | string
    comment?: StringFilter<"comentsProduct"> | string
    rating?: FloatFilter<"comentsProduct"> | number
    created_at?: DateTimeFilter<"comentsProduct"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type comentsProductOrderByWithAggregationInput = {
    id?: SortOrder
    idProduct?: SortOrder
    idUser?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
    _count?: comentsProductCountOrderByAggregateInput
    _avg?: comentsProductAvgOrderByAggregateInput
    _max?: comentsProductMaxOrderByAggregateInput
    _min?: comentsProductMinOrderByAggregateInput
    _sum?: comentsProductSumOrderByAggregateInput
  }

  export type comentsProductScalarWhereWithAggregatesInput = {
    AND?: comentsProductScalarWhereWithAggregatesInput | comentsProductScalarWhereWithAggregatesInput[]
    OR?: comentsProductScalarWhereWithAggregatesInput[]
    NOT?: comentsProductScalarWhereWithAggregatesInput | comentsProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"comentsProduct"> | string
    idProduct?: StringWithAggregatesFilter<"comentsProduct"> | string
    idUser?: StringWithAggregatesFilter<"comentsProduct"> | string
    comment?: StringWithAggregatesFilter<"comentsProduct"> | string
    rating?: FloatWithAggregatesFilter<"comentsProduct"> | number
    created_at?: DateTimeWithAggregatesFilter<"comentsProduct"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    phoneNumber?: string | null
    profilePic?: string | null
    superUser?: boolean
    alamat?: AlamatCreateNestedOneWithoutUserInput
    comentsUser?: comentsProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    phoneNumber?: string | null
    profilePic?: string | null
    superUser?: boolean
    alamat?: AlamatUncheckedCreateNestedOneWithoutUserInput
    comentsUser?: comentsProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
    alamat?: AlamatUpdateOneWithoutUserNestedInput
    comentsUser?: comentsProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
    alamat?: AlamatUncheckedUpdateOneWithoutUserNestedInput
    comentsUser?: comentsProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    phoneNumber?: string | null
    profilePic?: string | null
    superUser?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlamatCreateInput = {
    id?: string
    provinsi: string
    kabupaten: string
    kecamatan: string
    kodepos: string
    detail: string
    user: UserCreateNestedOneWithoutAlamatInput
  }

  export type AlamatUncheckedCreateInput = {
    id?: string
    idUser: string
    provinsi: string
    kabupaten: string
    kecamatan: string
    kodepos: string
    detail: string
  }

  export type AlamatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutAlamatNestedInput
  }

  export type AlamatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idUser?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type AlamatCreateManyInput = {
    id?: string
    idUser: string
    provinsi: string
    kabupaten: string
    kecamatan: string
    kodepos: string
    detail: string
  }

  export type AlamatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type AlamatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idUser?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductCreateInput = {
    id: string
    nameCategory: string
    subCategories?: SubCategoryProductCreateNestedManyWithoutCategoryProductInput
  }

  export type CategoryProductUncheckedCreateInput = {
    id: string
    nameCategory: string
    subCategories?: SubCategoryProductUncheckedCreateNestedManyWithoutCategoryProductInput
  }

  export type CategoryProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCategory?: StringFieldUpdateOperationsInput | string
    subCategories?: SubCategoryProductUpdateManyWithoutCategoryProductNestedInput
  }

  export type CategoryProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCategory?: StringFieldUpdateOperationsInput | string
    subCategories?: SubCategoryProductUncheckedUpdateManyWithoutCategoryProductNestedInput
  }

  export type CategoryProductCreateManyInput = {
    id: string
    nameCategory: string
  }

  export type CategoryProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCategory?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCategory?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryProductCreateInput = {
    id: string
    nameSubCategory: string
    products?: ProductCreateNestedManyWithoutSubCategoryInput
    categoryProduct: CategoryProductCreateNestedOneWithoutSubCategoriesInput
  }

  export type SubCategoryProductUncheckedCreateInput = {
    id: string
    nameSubCategory: string
    idCategory: string
    products?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutSubCategoryNestedInput
    categoryProduct?: CategoryProductUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type SubCategoryProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
    idCategory?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryProductCreateManyInput = {
    id: string
    nameSubCategory: string
    idCategory: string
  }

  export type SubCategoryProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
  }

  export type SubCategoryProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
    idCategory?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    comentsProduct?: comentsProductCreateNestedManyWithoutProductInput
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
    subCategory: SubCategoryProductCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    idSubCategory: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    comentsProduct?: comentsProductUncheckedCreateNestedManyWithoutProductInput
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    comentsProduct?: comentsProductUpdateManyWithoutProductNestedInput
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
    subCategory?: SubCategoryProductUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idSubCategory?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    comentsProduct?: comentsProductUncheckedUpdateManyWithoutProductNestedInput
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    idSubCategory: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idSubCategory?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductDetailCreateInput = {
    id?: string
    colorProduct: string
    pictureProduct: string
    sizes?: SizeCreateNestedManyWithoutProductDetailInput
    product: ProductCreateNestedOneWithoutProductDetailsInput
  }

  export type ProductDetailUncheckedCreateInput = {
    id?: string
    idProduct: string
    colorProduct: string
    pictureProduct: string
    sizes?: SizeUncheckedCreateNestedManyWithoutProductDetailInput
  }

  export type ProductDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
    sizes?: SizeUpdateManyWithoutProductDetailNestedInput
    product?: ProductUpdateOneRequiredWithoutProductDetailsNestedInput
  }

  export type ProductDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProduct?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
    sizes?: SizeUncheckedUpdateManyWithoutProductDetailNestedInput
  }

  export type ProductDetailCreateManyInput = {
    id?: string
    idProduct: string
    colorProduct: string
    pictureProduct: string
  }

  export type ProductDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
  }

  export type ProductDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProduct?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
  }

  export type SizeCreateInput = {
    id?: string
    sizeProduct: string
    stockProduct: number
    productDetail: ProductDetailCreateNestedOneWithoutSizesInput
  }

  export type SizeUncheckedCreateInput = {
    id?: string
    idProductDetail: string
    sizeProduct: string
    stockProduct: number
  }

  export type SizeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sizeProduct?: StringFieldUpdateOperationsInput | string
    stockProduct?: IntFieldUpdateOperationsInput | number
    productDetail?: ProductDetailUpdateOneRequiredWithoutSizesNestedInput
  }

  export type SizeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProductDetail?: StringFieldUpdateOperationsInput | string
    sizeProduct?: StringFieldUpdateOperationsInput | string
    stockProduct?: IntFieldUpdateOperationsInput | number
  }

  export type SizeCreateManyInput = {
    id?: string
    idProductDetail: string
    sizeProduct: string
    stockProduct: number
  }

  export type SizeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sizeProduct?: StringFieldUpdateOperationsInput | string
    stockProduct?: IntFieldUpdateOperationsInput | number
  }

  export type SizeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProductDetail?: StringFieldUpdateOperationsInput | string
    sizeProduct?: StringFieldUpdateOperationsInput | string
    stockProduct?: IntFieldUpdateOperationsInput | number
  }

  export type comentsProductCreateInput = {
    id?: string
    comment: string
    rating: number
    created_at?: Date | string
    user: UserCreateNestedOneWithoutComentsUserInput
    product: ProductCreateNestedOneWithoutComentsProductInput
  }

  export type comentsProductUncheckedCreateInput = {
    id?: string
    idProduct: string
    idUser: string
    comment: string
    rating: number
    created_at?: Date | string
  }

  export type comentsProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComentsUserNestedInput
    product?: ProductUpdateOneRequiredWithoutComentsProductNestedInput
  }

  export type comentsProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProduct?: StringFieldUpdateOperationsInput | string
    idUser?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentsProductCreateManyInput = {
    id?: string
    idProduct: string
    idUser: string
    comment: string
    rating: number
    created_at?: Date | string
  }

  export type comentsProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentsProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProduct?: StringFieldUpdateOperationsInput | string
    idUser?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AlamatNullableRelationFilter = {
    is?: AlamatWhereInput | null
    isNot?: AlamatWhereInput | null
  }

  export type ComentsProductListRelationFilter = {
    every?: comentsProductWhereInput
    some?: comentsProductWhereInput
    none?: comentsProductWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type comentsProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    profilePic?: SortOrder
    superUser?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    profilePic?: SortOrder
    superUser?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    profilePic?: SortOrder
    superUser?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AlamatCountOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kodepos?: SortOrder
    detail?: SortOrder
  }

  export type AlamatMaxOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kodepos?: SortOrder
    detail?: SortOrder
  }

  export type AlamatMinOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kodepos?: SortOrder
    detail?: SortOrder
  }

  export type SubCategoryProductListRelationFilter = {
    every?: SubCategoryProductWhereInput
    some?: SubCategoryProductWhereInput
    none?: SubCategoryProductWhereInput
  }

  export type SubCategoryProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryProductCountOrderByAggregateInput = {
    id?: SortOrder
    nameCategory?: SortOrder
  }

  export type CategoryProductMaxOrderByAggregateInput = {
    id?: SortOrder
    nameCategory?: SortOrder
  }

  export type CategoryProductMinOrderByAggregateInput = {
    id?: SortOrder
    nameCategory?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CategoryProductRelationFilter = {
    is?: CategoryProductWhereInput
    isNot?: CategoryProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubCategoryProductCountOrderByAggregateInput = {
    id?: SortOrder
    nameSubCategory?: SortOrder
    idCategory?: SortOrder
  }

  export type SubCategoryProductMaxOrderByAggregateInput = {
    id?: SortOrder
    nameSubCategory?: SortOrder
    idCategory?: SortOrder
  }

  export type SubCategoryProductMinOrderByAggregateInput = {
    id?: SortOrder
    nameSubCategory?: SortOrder
    idCategory?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductDetailListRelationFilter = {
    every?: ProductDetailWhereInput
    some?: ProductDetailWhereInput
    none?: ProductDetailWhereInput
  }

  export type SubCategoryProductRelationFilter = {
    is?: SubCategoryProductWhereInput
    isNot?: SubCategoryProductWhereInput
  }

  export type ProductDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    idSubCategory?: SortOrder
    nameProduct?: SortOrder
    priceProduct?: SortOrder
    descProduct?: SortOrder
    discountProduct?: SortOrder
    starProduct?: SortOrder
    gender?: SortOrder
    recommendedProduct?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    priceProduct?: SortOrder
    discountProduct?: SortOrder
    starProduct?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    idSubCategory?: SortOrder
    nameProduct?: SortOrder
    priceProduct?: SortOrder
    descProduct?: SortOrder
    discountProduct?: SortOrder
    starProduct?: SortOrder
    gender?: SortOrder
    recommendedProduct?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    idSubCategory?: SortOrder
    nameProduct?: SortOrder
    priceProduct?: SortOrder
    descProduct?: SortOrder
    discountProduct?: SortOrder
    starProduct?: SortOrder
    gender?: SortOrder
    recommendedProduct?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    priceProduct?: SortOrder
    discountProduct?: SortOrder
    starProduct?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SizeListRelationFilter = {
    every?: SizeWhereInput
    some?: SizeWhereInput
    none?: SizeWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type SizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductDetailCountOrderByAggregateInput = {
    id?: SortOrder
    idProduct?: SortOrder
    colorProduct?: SortOrder
    pictureProduct?: SortOrder
  }

  export type ProductDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    idProduct?: SortOrder
    colorProduct?: SortOrder
    pictureProduct?: SortOrder
  }

  export type ProductDetailMinOrderByAggregateInput = {
    id?: SortOrder
    idProduct?: SortOrder
    colorProduct?: SortOrder
    pictureProduct?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductDetailRelationFilter = {
    is?: ProductDetailWhereInput
    isNot?: ProductDetailWhereInput
  }

  export type SizeCountOrderByAggregateInput = {
    id?: SortOrder
    idProductDetail?: SortOrder
    sizeProduct?: SortOrder
    stockProduct?: SortOrder
  }

  export type SizeAvgOrderByAggregateInput = {
    stockProduct?: SortOrder
  }

  export type SizeMaxOrderByAggregateInput = {
    id?: SortOrder
    idProductDetail?: SortOrder
    sizeProduct?: SortOrder
    stockProduct?: SortOrder
  }

  export type SizeMinOrderByAggregateInput = {
    id?: SortOrder
    idProductDetail?: SortOrder
    sizeProduct?: SortOrder
    stockProduct?: SortOrder
  }

  export type SizeSumOrderByAggregateInput = {
    stockProduct?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type comentsProductCountOrderByAggregateInput = {
    id?: SortOrder
    idProduct?: SortOrder
    idUser?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
  }

  export type comentsProductAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type comentsProductMaxOrderByAggregateInput = {
    id?: SortOrder
    idProduct?: SortOrder
    idUser?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
  }

  export type comentsProductMinOrderByAggregateInput = {
    id?: SortOrder
    idProduct?: SortOrder
    idUser?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
  }

  export type comentsProductSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AlamatCreateNestedOneWithoutUserInput = {
    create?: XOR<AlamatCreateWithoutUserInput, AlamatUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlamatCreateOrConnectWithoutUserInput
    connect?: AlamatWhereUniqueInput
  }

  export type comentsProductCreateNestedManyWithoutUserInput = {
    create?: XOR<comentsProductCreateWithoutUserInput, comentsProductUncheckedCreateWithoutUserInput> | comentsProductCreateWithoutUserInput[] | comentsProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutUserInput | comentsProductCreateOrConnectWithoutUserInput[]
    createMany?: comentsProductCreateManyUserInputEnvelope
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
  }

  export type AlamatUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AlamatCreateWithoutUserInput, AlamatUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlamatCreateOrConnectWithoutUserInput
    connect?: AlamatWhereUniqueInput
  }

  export type comentsProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<comentsProductCreateWithoutUserInput, comentsProductUncheckedCreateWithoutUserInput> | comentsProductCreateWithoutUserInput[] | comentsProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutUserInput | comentsProductCreateOrConnectWithoutUserInput[]
    createMany?: comentsProductCreateManyUserInputEnvelope
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AlamatUpdateOneWithoutUserNestedInput = {
    create?: XOR<AlamatCreateWithoutUserInput, AlamatUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlamatCreateOrConnectWithoutUserInput
    upsert?: AlamatUpsertWithoutUserInput
    disconnect?: AlamatWhereInput | boolean
    delete?: AlamatWhereInput | boolean
    connect?: AlamatWhereUniqueInput
    update?: XOR<XOR<AlamatUpdateToOneWithWhereWithoutUserInput, AlamatUpdateWithoutUserInput>, AlamatUncheckedUpdateWithoutUserInput>
  }

  export type comentsProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<comentsProductCreateWithoutUserInput, comentsProductUncheckedCreateWithoutUserInput> | comentsProductCreateWithoutUserInput[] | comentsProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutUserInput | comentsProductCreateOrConnectWithoutUserInput[]
    upsert?: comentsProductUpsertWithWhereUniqueWithoutUserInput | comentsProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comentsProductCreateManyUserInputEnvelope
    set?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    disconnect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    delete?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    update?: comentsProductUpdateWithWhereUniqueWithoutUserInput | comentsProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comentsProductUpdateManyWithWhereWithoutUserInput | comentsProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comentsProductScalarWhereInput | comentsProductScalarWhereInput[]
  }

  export type AlamatUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AlamatCreateWithoutUserInput, AlamatUncheckedCreateWithoutUserInput>
    connectOrCreate?: AlamatCreateOrConnectWithoutUserInput
    upsert?: AlamatUpsertWithoutUserInput
    disconnect?: AlamatWhereInput | boolean
    delete?: AlamatWhereInput | boolean
    connect?: AlamatWhereUniqueInput
    update?: XOR<XOR<AlamatUpdateToOneWithWhereWithoutUserInput, AlamatUpdateWithoutUserInput>, AlamatUncheckedUpdateWithoutUserInput>
  }

  export type comentsProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<comentsProductCreateWithoutUserInput, comentsProductUncheckedCreateWithoutUserInput> | comentsProductCreateWithoutUserInput[] | comentsProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutUserInput | comentsProductCreateOrConnectWithoutUserInput[]
    upsert?: comentsProductUpsertWithWhereUniqueWithoutUserInput | comentsProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comentsProductCreateManyUserInputEnvelope
    set?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    disconnect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    delete?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    update?: comentsProductUpdateWithWhereUniqueWithoutUserInput | comentsProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comentsProductUpdateManyWithWhereWithoutUserInput | comentsProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comentsProductScalarWhereInput | comentsProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAlamatInput = {
    create?: XOR<UserCreateWithoutAlamatInput, UserUncheckedCreateWithoutAlamatInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlamatInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAlamatNestedInput = {
    create?: XOR<UserCreateWithoutAlamatInput, UserUncheckedCreateWithoutAlamatInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlamatInput
    upsert?: UserUpsertWithoutAlamatInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlamatInput, UserUpdateWithoutAlamatInput>, UserUncheckedUpdateWithoutAlamatInput>
  }

  export type SubCategoryProductCreateNestedManyWithoutCategoryProductInput = {
    create?: XOR<SubCategoryProductCreateWithoutCategoryProductInput, SubCategoryProductUncheckedCreateWithoutCategoryProductInput> | SubCategoryProductCreateWithoutCategoryProductInput[] | SubCategoryProductUncheckedCreateWithoutCategoryProductInput[]
    connectOrCreate?: SubCategoryProductCreateOrConnectWithoutCategoryProductInput | SubCategoryProductCreateOrConnectWithoutCategoryProductInput[]
    createMany?: SubCategoryProductCreateManyCategoryProductInputEnvelope
    connect?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
  }

  export type SubCategoryProductUncheckedCreateNestedManyWithoutCategoryProductInput = {
    create?: XOR<SubCategoryProductCreateWithoutCategoryProductInput, SubCategoryProductUncheckedCreateWithoutCategoryProductInput> | SubCategoryProductCreateWithoutCategoryProductInput[] | SubCategoryProductUncheckedCreateWithoutCategoryProductInput[]
    connectOrCreate?: SubCategoryProductCreateOrConnectWithoutCategoryProductInput | SubCategoryProductCreateOrConnectWithoutCategoryProductInput[]
    createMany?: SubCategoryProductCreateManyCategoryProductInputEnvelope
    connect?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
  }

  export type SubCategoryProductUpdateManyWithoutCategoryProductNestedInput = {
    create?: XOR<SubCategoryProductCreateWithoutCategoryProductInput, SubCategoryProductUncheckedCreateWithoutCategoryProductInput> | SubCategoryProductCreateWithoutCategoryProductInput[] | SubCategoryProductUncheckedCreateWithoutCategoryProductInput[]
    connectOrCreate?: SubCategoryProductCreateOrConnectWithoutCategoryProductInput | SubCategoryProductCreateOrConnectWithoutCategoryProductInput[]
    upsert?: SubCategoryProductUpsertWithWhereUniqueWithoutCategoryProductInput | SubCategoryProductUpsertWithWhereUniqueWithoutCategoryProductInput[]
    createMany?: SubCategoryProductCreateManyCategoryProductInputEnvelope
    set?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    disconnect?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    delete?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    connect?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    update?: SubCategoryProductUpdateWithWhereUniqueWithoutCategoryProductInput | SubCategoryProductUpdateWithWhereUniqueWithoutCategoryProductInput[]
    updateMany?: SubCategoryProductUpdateManyWithWhereWithoutCategoryProductInput | SubCategoryProductUpdateManyWithWhereWithoutCategoryProductInput[]
    deleteMany?: SubCategoryProductScalarWhereInput | SubCategoryProductScalarWhereInput[]
  }

  export type SubCategoryProductUncheckedUpdateManyWithoutCategoryProductNestedInput = {
    create?: XOR<SubCategoryProductCreateWithoutCategoryProductInput, SubCategoryProductUncheckedCreateWithoutCategoryProductInput> | SubCategoryProductCreateWithoutCategoryProductInput[] | SubCategoryProductUncheckedCreateWithoutCategoryProductInput[]
    connectOrCreate?: SubCategoryProductCreateOrConnectWithoutCategoryProductInput | SubCategoryProductCreateOrConnectWithoutCategoryProductInput[]
    upsert?: SubCategoryProductUpsertWithWhereUniqueWithoutCategoryProductInput | SubCategoryProductUpsertWithWhereUniqueWithoutCategoryProductInput[]
    createMany?: SubCategoryProductCreateManyCategoryProductInputEnvelope
    set?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    disconnect?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    delete?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    connect?: SubCategoryProductWhereUniqueInput | SubCategoryProductWhereUniqueInput[]
    update?: SubCategoryProductUpdateWithWhereUniqueWithoutCategoryProductInput | SubCategoryProductUpdateWithWhereUniqueWithoutCategoryProductInput[]
    updateMany?: SubCategoryProductUpdateManyWithWhereWithoutCategoryProductInput | SubCategoryProductUpdateManyWithWhereWithoutCategoryProductInput[]
    deleteMany?: SubCategoryProductScalarWhereInput | SubCategoryProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryProductCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<CategoryProductCreateWithoutSubCategoriesInput, CategoryProductUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryProductCreateOrConnectWithoutSubCategoriesInput
    connect?: CategoryProductWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryProductUpdateOneRequiredWithoutSubCategoriesNestedInput = {
    create?: XOR<CategoryProductCreateWithoutSubCategoriesInput, CategoryProductUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryProductCreateOrConnectWithoutSubCategoriesInput
    upsert?: CategoryProductUpsertWithoutSubCategoriesInput
    connect?: CategoryProductWhereUniqueInput
    update?: XOR<XOR<CategoryProductUpdateToOneWithWhereWithoutSubCategoriesInput, CategoryProductUpdateWithoutSubCategoriesInput>, CategoryProductUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: ProductCreateManySubCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type comentsProductCreateNestedManyWithoutProductInput = {
    create?: XOR<comentsProductCreateWithoutProductInput, comentsProductUncheckedCreateWithoutProductInput> | comentsProductCreateWithoutProductInput[] | comentsProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutProductInput | comentsProductCreateOrConnectWithoutProductInput[]
    createMany?: comentsProductCreateManyProductInputEnvelope
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
  }

  export type ProductDetailCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
  }

  export type SubCategoryProductCreateNestedOneWithoutProductsInput = {
    create?: XOR<SubCategoryProductCreateWithoutProductsInput, SubCategoryProductUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubCategoryProductCreateOrConnectWithoutProductsInput
    connect?: SubCategoryProductWhereUniqueInput
  }

  export type comentsProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<comentsProductCreateWithoutProductInput, comentsProductUncheckedCreateWithoutProductInput> | comentsProductCreateWithoutProductInput[] | comentsProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutProductInput | comentsProductCreateOrConnectWithoutProductInput[]
    createMany?: comentsProductCreateManyProductInputEnvelope
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
  }

  export type ProductDetailUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type comentsProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<comentsProductCreateWithoutProductInput, comentsProductUncheckedCreateWithoutProductInput> | comentsProductCreateWithoutProductInput[] | comentsProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutProductInput | comentsProductCreateOrConnectWithoutProductInput[]
    upsert?: comentsProductUpsertWithWhereUniqueWithoutProductInput | comentsProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: comentsProductCreateManyProductInputEnvelope
    set?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    disconnect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    delete?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    update?: comentsProductUpdateWithWhereUniqueWithoutProductInput | comentsProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: comentsProductUpdateManyWithWhereWithoutProductInput | comentsProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: comentsProductScalarWhereInput | comentsProductScalarWhereInput[]
  }

  export type ProductDetailUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    upsert?: ProductDetailUpsertWithWhereUniqueWithoutProductInput | ProductDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    set?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    disconnect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    delete?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    update?: ProductDetailUpdateWithWhereUniqueWithoutProductInput | ProductDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductDetailUpdateManyWithWhereWithoutProductInput | ProductDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
  }

  export type SubCategoryProductUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SubCategoryProductCreateWithoutProductsInput, SubCategoryProductUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubCategoryProductCreateOrConnectWithoutProductsInput
    upsert?: SubCategoryProductUpsertWithoutProductsInput
    connect?: SubCategoryProductWhereUniqueInput
    update?: XOR<XOR<SubCategoryProductUpdateToOneWithWhereWithoutProductsInput, SubCategoryProductUpdateWithoutProductsInput>, SubCategoryProductUncheckedUpdateWithoutProductsInput>
  }

  export type comentsProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<comentsProductCreateWithoutProductInput, comentsProductUncheckedCreateWithoutProductInput> | comentsProductCreateWithoutProductInput[] | comentsProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: comentsProductCreateOrConnectWithoutProductInput | comentsProductCreateOrConnectWithoutProductInput[]
    upsert?: comentsProductUpsertWithWhereUniqueWithoutProductInput | comentsProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: comentsProductCreateManyProductInputEnvelope
    set?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    disconnect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    delete?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    connect?: comentsProductWhereUniqueInput | comentsProductWhereUniqueInput[]
    update?: comentsProductUpdateWithWhereUniqueWithoutProductInput | comentsProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: comentsProductUpdateManyWithWhereWithoutProductInput | comentsProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: comentsProductScalarWhereInput | comentsProductScalarWhereInput[]
  }

  export type ProductDetailUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    upsert?: ProductDetailUpsertWithWhereUniqueWithoutProductInput | ProductDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    set?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    disconnect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    delete?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    update?: ProductDetailUpdateWithWhereUniqueWithoutProductInput | ProductDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductDetailUpdateManyWithWhereWithoutProductInput | ProductDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
  }

  export type SizeCreateNestedManyWithoutProductDetailInput = {
    create?: XOR<SizeCreateWithoutProductDetailInput, SizeUncheckedCreateWithoutProductDetailInput> | SizeCreateWithoutProductDetailInput[] | SizeUncheckedCreateWithoutProductDetailInput[]
    connectOrCreate?: SizeCreateOrConnectWithoutProductDetailInput | SizeCreateOrConnectWithoutProductDetailInput[]
    createMany?: SizeCreateManyProductDetailInputEnvelope
    connect?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
  }

  export type ProductCreateNestedOneWithoutProductDetailsInput = {
    create?: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductDetailsInput
    connect?: ProductWhereUniqueInput
  }

  export type SizeUncheckedCreateNestedManyWithoutProductDetailInput = {
    create?: XOR<SizeCreateWithoutProductDetailInput, SizeUncheckedCreateWithoutProductDetailInput> | SizeCreateWithoutProductDetailInput[] | SizeUncheckedCreateWithoutProductDetailInput[]
    connectOrCreate?: SizeCreateOrConnectWithoutProductDetailInput | SizeCreateOrConnectWithoutProductDetailInput[]
    createMany?: SizeCreateManyProductDetailInputEnvelope
    connect?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
  }

  export type SizeUpdateManyWithoutProductDetailNestedInput = {
    create?: XOR<SizeCreateWithoutProductDetailInput, SizeUncheckedCreateWithoutProductDetailInput> | SizeCreateWithoutProductDetailInput[] | SizeUncheckedCreateWithoutProductDetailInput[]
    connectOrCreate?: SizeCreateOrConnectWithoutProductDetailInput | SizeCreateOrConnectWithoutProductDetailInput[]
    upsert?: SizeUpsertWithWhereUniqueWithoutProductDetailInput | SizeUpsertWithWhereUniqueWithoutProductDetailInput[]
    createMany?: SizeCreateManyProductDetailInputEnvelope
    set?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    disconnect?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    delete?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    connect?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    update?: SizeUpdateWithWhereUniqueWithoutProductDetailInput | SizeUpdateWithWhereUniqueWithoutProductDetailInput[]
    updateMany?: SizeUpdateManyWithWhereWithoutProductDetailInput | SizeUpdateManyWithWhereWithoutProductDetailInput[]
    deleteMany?: SizeScalarWhereInput | SizeScalarWhereInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductDetailsInput
    upsert?: ProductUpsertWithoutProductDetailsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductDetailsInput, ProductUpdateWithoutProductDetailsInput>, ProductUncheckedUpdateWithoutProductDetailsInput>
  }

  export type SizeUncheckedUpdateManyWithoutProductDetailNestedInput = {
    create?: XOR<SizeCreateWithoutProductDetailInput, SizeUncheckedCreateWithoutProductDetailInput> | SizeCreateWithoutProductDetailInput[] | SizeUncheckedCreateWithoutProductDetailInput[]
    connectOrCreate?: SizeCreateOrConnectWithoutProductDetailInput | SizeCreateOrConnectWithoutProductDetailInput[]
    upsert?: SizeUpsertWithWhereUniqueWithoutProductDetailInput | SizeUpsertWithWhereUniqueWithoutProductDetailInput[]
    createMany?: SizeCreateManyProductDetailInputEnvelope
    set?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    disconnect?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    delete?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    connect?: SizeWhereUniqueInput | SizeWhereUniqueInput[]
    update?: SizeUpdateWithWhereUniqueWithoutProductDetailInput | SizeUpdateWithWhereUniqueWithoutProductDetailInput[]
    updateMany?: SizeUpdateManyWithWhereWithoutProductDetailInput | SizeUpdateManyWithWhereWithoutProductDetailInput[]
    deleteMany?: SizeScalarWhereInput | SizeScalarWhereInput[]
  }

  export type ProductDetailCreateNestedOneWithoutSizesInput = {
    create?: XOR<ProductDetailCreateWithoutSizesInput, ProductDetailUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ProductDetailCreateOrConnectWithoutSizesInput
    connect?: ProductDetailWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductDetailUpdateOneRequiredWithoutSizesNestedInput = {
    create?: XOR<ProductDetailCreateWithoutSizesInput, ProductDetailUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ProductDetailCreateOrConnectWithoutSizesInput
    upsert?: ProductDetailUpsertWithoutSizesInput
    connect?: ProductDetailWhereUniqueInput
    update?: XOR<XOR<ProductDetailUpdateToOneWithWhereWithoutSizesInput, ProductDetailUpdateWithoutSizesInput>, ProductDetailUncheckedUpdateWithoutSizesInput>
  }

  export type UserCreateNestedOneWithoutComentsUserInput = {
    create?: XOR<UserCreateWithoutComentsUserInput, UserUncheckedCreateWithoutComentsUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutComentsUserInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutComentsProductInput = {
    create?: XOR<ProductCreateWithoutComentsProductInput, ProductUncheckedCreateWithoutComentsProductInput>
    connectOrCreate?: ProductCreateOrConnectWithoutComentsProductInput
    connect?: ProductWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutComentsUserNestedInput = {
    create?: XOR<UserCreateWithoutComentsUserInput, UserUncheckedCreateWithoutComentsUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutComentsUserInput
    upsert?: UserUpsertWithoutComentsUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComentsUserInput, UserUpdateWithoutComentsUserInput>, UserUncheckedUpdateWithoutComentsUserInput>
  }

  export type ProductUpdateOneRequiredWithoutComentsProductNestedInput = {
    create?: XOR<ProductCreateWithoutComentsProductInput, ProductUncheckedCreateWithoutComentsProductInput>
    connectOrCreate?: ProductCreateOrConnectWithoutComentsProductInput
    upsert?: ProductUpsertWithoutComentsProductInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutComentsProductInput, ProductUpdateWithoutComentsProductInput>, ProductUncheckedUpdateWithoutComentsProductInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AlamatCreateWithoutUserInput = {
    id?: string
    provinsi: string
    kabupaten: string
    kecamatan: string
    kodepos: string
    detail: string
  }

  export type AlamatUncheckedCreateWithoutUserInput = {
    id?: string
    provinsi: string
    kabupaten: string
    kecamatan: string
    kodepos: string
    detail: string
  }

  export type AlamatCreateOrConnectWithoutUserInput = {
    where: AlamatWhereUniqueInput
    create: XOR<AlamatCreateWithoutUserInput, AlamatUncheckedCreateWithoutUserInput>
  }

  export type comentsProductCreateWithoutUserInput = {
    id?: string
    comment: string
    rating: number
    created_at?: Date | string
    product: ProductCreateNestedOneWithoutComentsProductInput
  }

  export type comentsProductUncheckedCreateWithoutUserInput = {
    id?: string
    idProduct: string
    comment: string
    rating: number
    created_at?: Date | string
  }

  export type comentsProductCreateOrConnectWithoutUserInput = {
    where: comentsProductWhereUniqueInput
    create: XOR<comentsProductCreateWithoutUserInput, comentsProductUncheckedCreateWithoutUserInput>
  }

  export type comentsProductCreateManyUserInputEnvelope = {
    data: comentsProductCreateManyUserInput | comentsProductCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AlamatUpsertWithoutUserInput = {
    update: XOR<AlamatUpdateWithoutUserInput, AlamatUncheckedUpdateWithoutUserInput>
    create: XOR<AlamatCreateWithoutUserInput, AlamatUncheckedCreateWithoutUserInput>
    where?: AlamatWhereInput
  }

  export type AlamatUpdateToOneWithWhereWithoutUserInput = {
    where?: AlamatWhereInput
    data: XOR<AlamatUpdateWithoutUserInput, AlamatUncheckedUpdateWithoutUserInput>
  }

  export type AlamatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type AlamatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type comentsProductUpsertWithWhereUniqueWithoutUserInput = {
    where: comentsProductWhereUniqueInput
    update: XOR<comentsProductUpdateWithoutUserInput, comentsProductUncheckedUpdateWithoutUserInput>
    create: XOR<comentsProductCreateWithoutUserInput, comentsProductUncheckedCreateWithoutUserInput>
  }

  export type comentsProductUpdateWithWhereUniqueWithoutUserInput = {
    where: comentsProductWhereUniqueInput
    data: XOR<comentsProductUpdateWithoutUserInput, comentsProductUncheckedUpdateWithoutUserInput>
  }

  export type comentsProductUpdateManyWithWhereWithoutUserInput = {
    where: comentsProductScalarWhereInput
    data: XOR<comentsProductUpdateManyMutationInput, comentsProductUncheckedUpdateManyWithoutUserInput>
  }

  export type comentsProductScalarWhereInput = {
    AND?: comentsProductScalarWhereInput | comentsProductScalarWhereInput[]
    OR?: comentsProductScalarWhereInput[]
    NOT?: comentsProductScalarWhereInput | comentsProductScalarWhereInput[]
    id?: StringFilter<"comentsProduct"> | string
    idProduct?: StringFilter<"comentsProduct"> | string
    idUser?: StringFilter<"comentsProduct"> | string
    comment?: StringFilter<"comentsProduct"> | string
    rating?: FloatFilter<"comentsProduct"> | number
    created_at?: DateTimeFilter<"comentsProduct"> | Date | string
  }

  export type UserCreateWithoutAlamatInput = {
    id?: string
    name: string
    email: string
    password: string
    phoneNumber?: string | null
    profilePic?: string | null
    superUser?: boolean
    comentsUser?: comentsProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlamatInput = {
    id?: string
    name: string
    email: string
    password: string
    phoneNumber?: string | null
    profilePic?: string | null
    superUser?: boolean
    comentsUser?: comentsProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlamatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlamatInput, UserUncheckedCreateWithoutAlamatInput>
  }

  export type UserUpsertWithoutAlamatInput = {
    update: XOR<UserUpdateWithoutAlamatInput, UserUncheckedUpdateWithoutAlamatInput>
    create: XOR<UserCreateWithoutAlamatInput, UserUncheckedCreateWithoutAlamatInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlamatInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlamatInput, UserUncheckedUpdateWithoutAlamatInput>
  }

  export type UserUpdateWithoutAlamatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
    comentsUser?: comentsProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlamatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
    comentsUser?: comentsProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubCategoryProductCreateWithoutCategoryProductInput = {
    id: string
    nameSubCategory: string
    products?: ProductCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryProductUncheckedCreateWithoutCategoryProductInput = {
    id: string
    nameSubCategory: string
    products?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryProductCreateOrConnectWithoutCategoryProductInput = {
    where: SubCategoryProductWhereUniqueInput
    create: XOR<SubCategoryProductCreateWithoutCategoryProductInput, SubCategoryProductUncheckedCreateWithoutCategoryProductInput>
  }

  export type SubCategoryProductCreateManyCategoryProductInputEnvelope = {
    data: SubCategoryProductCreateManyCategoryProductInput | SubCategoryProductCreateManyCategoryProductInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoryProductUpsertWithWhereUniqueWithoutCategoryProductInput = {
    where: SubCategoryProductWhereUniqueInput
    update: XOR<SubCategoryProductUpdateWithoutCategoryProductInput, SubCategoryProductUncheckedUpdateWithoutCategoryProductInput>
    create: XOR<SubCategoryProductCreateWithoutCategoryProductInput, SubCategoryProductUncheckedCreateWithoutCategoryProductInput>
  }

  export type SubCategoryProductUpdateWithWhereUniqueWithoutCategoryProductInput = {
    where: SubCategoryProductWhereUniqueInput
    data: XOR<SubCategoryProductUpdateWithoutCategoryProductInput, SubCategoryProductUncheckedUpdateWithoutCategoryProductInput>
  }

  export type SubCategoryProductUpdateManyWithWhereWithoutCategoryProductInput = {
    where: SubCategoryProductScalarWhereInput
    data: XOR<SubCategoryProductUpdateManyMutationInput, SubCategoryProductUncheckedUpdateManyWithoutCategoryProductInput>
  }

  export type SubCategoryProductScalarWhereInput = {
    AND?: SubCategoryProductScalarWhereInput | SubCategoryProductScalarWhereInput[]
    OR?: SubCategoryProductScalarWhereInput[]
    NOT?: SubCategoryProductScalarWhereInput | SubCategoryProductScalarWhereInput[]
    id?: StringFilter<"SubCategoryProduct"> | string
    nameSubCategory?: StringFilter<"SubCategoryProduct"> | string
    idCategory?: StringFilter<"SubCategoryProduct"> | string
  }

  export type ProductCreateWithoutSubCategoryInput = {
    id?: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    comentsProduct?: comentsProductCreateNestedManyWithoutProductInput
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSubCategoryInput = {
    id?: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    comentsProduct?: comentsProductUncheckedCreateNestedManyWithoutProductInput
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductCreateManySubCategoryInputEnvelope = {
    data: ProductCreateManySubCategoryInput | ProductCreateManySubCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryProductCreateWithoutSubCategoriesInput = {
    id: string
    nameCategory: string
  }

  export type CategoryProductUncheckedCreateWithoutSubCategoriesInput = {
    id: string
    nameCategory: string
  }

  export type CategoryProductCreateOrConnectWithoutSubCategoriesInput = {
    where: CategoryProductWhereUniqueInput
    create: XOR<CategoryProductCreateWithoutSubCategoriesInput, CategoryProductUncheckedCreateWithoutSubCategoriesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutSubCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    idSubCategory?: StringFilter<"Product"> | string
    nameProduct?: StringFilter<"Product"> | string
    priceProduct?: FloatFilter<"Product"> | number
    descProduct?: StringNullableFilter<"Product"> | string | null
    discountProduct?: FloatNullableFilter<"Product"> | number | null
    starProduct?: FloatNullableFilter<"Product"> | number | null
    gender?: StringNullableFilter<"Product"> | string | null
    recommendedProduct?: BoolFilter<"Product"> | boolean
  }

  export type CategoryProductUpsertWithoutSubCategoriesInput = {
    update: XOR<CategoryProductUpdateWithoutSubCategoriesInput, CategoryProductUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<CategoryProductCreateWithoutSubCategoriesInput, CategoryProductUncheckedCreateWithoutSubCategoriesInput>
    where?: CategoryProductWhereInput
  }

  export type CategoryProductUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: CategoryProductWhereInput
    data: XOR<CategoryProductUpdateWithoutSubCategoriesInput, CategoryProductUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type CategoryProductUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCategory?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryProductUncheckedUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameCategory?: StringFieldUpdateOperationsInput | string
  }

  export type comentsProductCreateWithoutProductInput = {
    id?: string
    comment: string
    rating: number
    created_at?: Date | string
    user: UserCreateNestedOneWithoutComentsUserInput
  }

  export type comentsProductUncheckedCreateWithoutProductInput = {
    id?: string
    idUser: string
    comment: string
    rating: number
    created_at?: Date | string
  }

  export type comentsProductCreateOrConnectWithoutProductInput = {
    where: comentsProductWhereUniqueInput
    create: XOR<comentsProductCreateWithoutProductInput, comentsProductUncheckedCreateWithoutProductInput>
  }

  export type comentsProductCreateManyProductInputEnvelope = {
    data: comentsProductCreateManyProductInput | comentsProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductDetailCreateWithoutProductInput = {
    id?: string
    colorProduct: string
    pictureProduct: string
    sizes?: SizeCreateNestedManyWithoutProductDetailInput
  }

  export type ProductDetailUncheckedCreateWithoutProductInput = {
    id?: string
    colorProduct: string
    pictureProduct: string
    sizes?: SizeUncheckedCreateNestedManyWithoutProductDetailInput
  }

  export type ProductDetailCreateOrConnectWithoutProductInput = {
    where: ProductDetailWhereUniqueInput
    create: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput>
  }

  export type ProductDetailCreateManyProductInputEnvelope = {
    data: ProductDetailCreateManyProductInput | ProductDetailCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoryProductCreateWithoutProductsInput = {
    id: string
    nameSubCategory: string
    categoryProduct: CategoryProductCreateNestedOneWithoutSubCategoriesInput
  }

  export type SubCategoryProductUncheckedCreateWithoutProductsInput = {
    id: string
    nameSubCategory: string
    idCategory: string
  }

  export type SubCategoryProductCreateOrConnectWithoutProductsInput = {
    where: SubCategoryProductWhereUniqueInput
    create: XOR<SubCategoryProductCreateWithoutProductsInput, SubCategoryProductUncheckedCreateWithoutProductsInput>
  }

  export type comentsProductUpsertWithWhereUniqueWithoutProductInput = {
    where: comentsProductWhereUniqueInput
    update: XOR<comentsProductUpdateWithoutProductInput, comentsProductUncheckedUpdateWithoutProductInput>
    create: XOR<comentsProductCreateWithoutProductInput, comentsProductUncheckedCreateWithoutProductInput>
  }

  export type comentsProductUpdateWithWhereUniqueWithoutProductInput = {
    where: comentsProductWhereUniqueInput
    data: XOR<comentsProductUpdateWithoutProductInput, comentsProductUncheckedUpdateWithoutProductInput>
  }

  export type comentsProductUpdateManyWithWhereWithoutProductInput = {
    where: comentsProductScalarWhereInput
    data: XOR<comentsProductUpdateManyMutationInput, comentsProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductDetailUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductDetailWhereUniqueInput
    update: XOR<ProductDetailUpdateWithoutProductInput, ProductDetailUncheckedUpdateWithoutProductInput>
    create: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput>
  }

  export type ProductDetailUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductDetailWhereUniqueInput
    data: XOR<ProductDetailUpdateWithoutProductInput, ProductDetailUncheckedUpdateWithoutProductInput>
  }

  export type ProductDetailUpdateManyWithWhereWithoutProductInput = {
    where: ProductDetailScalarWhereInput
    data: XOR<ProductDetailUpdateManyMutationInput, ProductDetailUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductDetailScalarWhereInput = {
    AND?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
    OR?: ProductDetailScalarWhereInput[]
    NOT?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
    id?: StringFilter<"ProductDetail"> | string
    idProduct?: StringFilter<"ProductDetail"> | string
    colorProduct?: StringFilter<"ProductDetail"> | string
    pictureProduct?: StringFilter<"ProductDetail"> | string
  }

  export type SubCategoryProductUpsertWithoutProductsInput = {
    update: XOR<SubCategoryProductUpdateWithoutProductsInput, SubCategoryProductUncheckedUpdateWithoutProductsInput>
    create: XOR<SubCategoryProductCreateWithoutProductsInput, SubCategoryProductUncheckedCreateWithoutProductsInput>
    where?: SubCategoryProductWhereInput
  }

  export type SubCategoryProductUpdateToOneWithWhereWithoutProductsInput = {
    where?: SubCategoryProductWhereInput
    data: XOR<SubCategoryProductUpdateWithoutProductsInput, SubCategoryProductUncheckedUpdateWithoutProductsInput>
  }

  export type SubCategoryProductUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
    categoryProduct?: CategoryProductUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type SubCategoryProductUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
    idCategory?: StringFieldUpdateOperationsInput | string
  }

  export type SizeCreateWithoutProductDetailInput = {
    id?: string
    sizeProduct: string
    stockProduct: number
  }

  export type SizeUncheckedCreateWithoutProductDetailInput = {
    id?: string
    sizeProduct: string
    stockProduct: number
  }

  export type SizeCreateOrConnectWithoutProductDetailInput = {
    where: SizeWhereUniqueInput
    create: XOR<SizeCreateWithoutProductDetailInput, SizeUncheckedCreateWithoutProductDetailInput>
  }

  export type SizeCreateManyProductDetailInputEnvelope = {
    data: SizeCreateManyProductDetailInput | SizeCreateManyProductDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutProductDetailsInput = {
    id?: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    comentsProduct?: comentsProductCreateNestedManyWithoutProductInput
    subCategory: SubCategoryProductCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutProductDetailsInput = {
    id?: string
    idSubCategory: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    comentsProduct?: comentsProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductDetailsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
  }

  export type SizeUpsertWithWhereUniqueWithoutProductDetailInput = {
    where: SizeWhereUniqueInput
    update: XOR<SizeUpdateWithoutProductDetailInput, SizeUncheckedUpdateWithoutProductDetailInput>
    create: XOR<SizeCreateWithoutProductDetailInput, SizeUncheckedCreateWithoutProductDetailInput>
  }

  export type SizeUpdateWithWhereUniqueWithoutProductDetailInput = {
    where: SizeWhereUniqueInput
    data: XOR<SizeUpdateWithoutProductDetailInput, SizeUncheckedUpdateWithoutProductDetailInput>
  }

  export type SizeUpdateManyWithWhereWithoutProductDetailInput = {
    where: SizeScalarWhereInput
    data: XOR<SizeUpdateManyMutationInput, SizeUncheckedUpdateManyWithoutProductDetailInput>
  }

  export type SizeScalarWhereInput = {
    AND?: SizeScalarWhereInput | SizeScalarWhereInput[]
    OR?: SizeScalarWhereInput[]
    NOT?: SizeScalarWhereInput | SizeScalarWhereInput[]
    id?: StringFilter<"Size"> | string
    idProductDetail?: StringFilter<"Size"> | string
    sizeProduct?: StringFilter<"Size"> | string
    stockProduct?: IntFilter<"Size"> | number
  }

  export type ProductUpsertWithoutProductDetailsInput = {
    update: XOR<ProductUpdateWithoutProductDetailsInput, ProductUncheckedUpdateWithoutProductDetailsInput>
    create: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductDetailsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductDetailsInput, ProductUncheckedUpdateWithoutProductDetailsInput>
  }

  export type ProductUpdateWithoutProductDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    comentsProduct?: comentsProductUpdateManyWithoutProductNestedInput
    subCategory?: SubCategoryProductUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    idSubCategory?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    comentsProduct?: comentsProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductDetailCreateWithoutSizesInput = {
    id?: string
    colorProduct: string
    pictureProduct: string
    product: ProductCreateNestedOneWithoutProductDetailsInput
  }

  export type ProductDetailUncheckedCreateWithoutSizesInput = {
    id?: string
    idProduct: string
    colorProduct: string
    pictureProduct: string
  }

  export type ProductDetailCreateOrConnectWithoutSizesInput = {
    where: ProductDetailWhereUniqueInput
    create: XOR<ProductDetailCreateWithoutSizesInput, ProductDetailUncheckedCreateWithoutSizesInput>
  }

  export type ProductDetailUpsertWithoutSizesInput = {
    update: XOR<ProductDetailUpdateWithoutSizesInput, ProductDetailUncheckedUpdateWithoutSizesInput>
    create: XOR<ProductDetailCreateWithoutSizesInput, ProductDetailUncheckedCreateWithoutSizesInput>
    where?: ProductDetailWhereInput
  }

  export type ProductDetailUpdateToOneWithWhereWithoutSizesInput = {
    where?: ProductDetailWhereInput
    data: XOR<ProductDetailUpdateWithoutSizesInput, ProductDetailUncheckedUpdateWithoutSizesInput>
  }

  export type ProductDetailUpdateWithoutSizesInput = {
    id?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutProductDetailsNestedInput
  }

  export type ProductDetailUncheckedUpdateWithoutSizesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProduct?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutComentsUserInput = {
    id?: string
    name: string
    email: string
    password: string
    phoneNumber?: string | null
    profilePic?: string | null
    superUser?: boolean
    alamat?: AlamatCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComentsUserInput = {
    id?: string
    name: string
    email: string
    password: string
    phoneNumber?: string | null
    profilePic?: string | null
    superUser?: boolean
    alamat?: AlamatUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComentsUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComentsUserInput, UserUncheckedCreateWithoutComentsUserInput>
  }

  export type ProductCreateWithoutComentsProductInput = {
    id?: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
    subCategory: SubCategoryProductCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutComentsProductInput = {
    id?: string
    idSubCategory: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutComentsProductInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutComentsProductInput, ProductUncheckedCreateWithoutComentsProductInput>
  }

  export type UserUpsertWithoutComentsUserInput = {
    update: XOR<UserUpdateWithoutComentsUserInput, UserUncheckedUpdateWithoutComentsUserInput>
    create: XOR<UserCreateWithoutComentsUserInput, UserUncheckedCreateWithoutComentsUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComentsUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComentsUserInput, UserUncheckedUpdateWithoutComentsUserInput>
  }

  export type UserUpdateWithoutComentsUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
    alamat?: AlamatUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComentsUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    profilePic?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: BoolFieldUpdateOperationsInput | boolean
    alamat?: AlamatUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProductUpsertWithoutComentsProductInput = {
    update: XOR<ProductUpdateWithoutComentsProductInput, ProductUncheckedUpdateWithoutComentsProductInput>
    create: XOR<ProductCreateWithoutComentsProductInput, ProductUncheckedCreateWithoutComentsProductInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutComentsProductInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutComentsProductInput, ProductUncheckedUpdateWithoutComentsProductInput>
  }

  export type ProductUpdateWithoutComentsProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
    subCategory?: SubCategoryProductUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutComentsProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    idSubCategory?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type comentsProductCreateManyUserInput = {
    id?: string
    idProduct: string
    comment: string
    rating: number
    created_at?: Date | string
  }

  export type comentsProductUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutComentsProductNestedInput
  }

  export type comentsProductUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProduct?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentsProductUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    idProduct?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryProductCreateManyCategoryProductInput = {
    id: string
    nameSubCategory: string
  }

  export type SubCategoryProductUpdateWithoutCategoryProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryProductUncheckedUpdateWithoutCategoryProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryProductUncheckedUpdateManyWithoutCategoryProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameSubCategory?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManySubCategoryInput = {
    id?: string
    nameProduct: string
    priceProduct: number
    descProduct?: string | null
    discountProduct?: number | null
    starProduct?: number | null
    gender?: string | null
    recommendedProduct?: boolean
  }

  export type ProductUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    comentsProduct?: comentsProductUpdateManyWithoutProductNestedInput
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
    comentsProduct?: comentsProductUncheckedUpdateManyWithoutProductNestedInput
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameProduct?: StringFieldUpdateOperationsInput | string
    priceProduct?: FloatFieldUpdateOperationsInput | number
    descProduct?: NullableStringFieldUpdateOperationsInput | string | null
    discountProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    starProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    recommendedProduct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type comentsProductCreateManyProductInput = {
    id?: string
    idUser: string
    comment: string
    rating: number
    created_at?: Date | string
  }

  export type ProductDetailCreateManyProductInput = {
    id?: string
    colorProduct: string
    pictureProduct: string
  }

  export type comentsProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutComentsUserNestedInput
  }

  export type comentsProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    idUser?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentsProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    idUser?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
    sizes?: SizeUpdateManyWithoutProductDetailNestedInput
  }

  export type ProductDetailUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
    sizes?: SizeUncheckedUpdateManyWithoutProductDetailNestedInput
  }

  export type ProductDetailUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    colorProduct?: StringFieldUpdateOperationsInput | string
    pictureProduct?: StringFieldUpdateOperationsInput | string
  }

  export type SizeCreateManyProductDetailInput = {
    id?: string
    sizeProduct: string
    stockProduct: number
  }

  export type SizeUpdateWithoutProductDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    sizeProduct?: StringFieldUpdateOperationsInput | string
    stockProduct?: IntFieldUpdateOperationsInput | number
  }

  export type SizeUncheckedUpdateWithoutProductDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    sizeProduct?: StringFieldUpdateOperationsInput | string
    stockProduct?: IntFieldUpdateOperationsInput | number
  }

  export type SizeUncheckedUpdateManyWithoutProductDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    sizeProduct?: StringFieldUpdateOperationsInput | string
    stockProduct?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryProductCountOutputTypeDefaultArgs instead
     */
    export type CategoryProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoryProductCountOutputTypeDefaultArgs instead
     */
    export type SubCategoryProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoryProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDetailCountOutputTypeDefaultArgs instead
     */
    export type ProductDetailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDetailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlamatDefaultArgs instead
     */
    export type AlamatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlamatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryProductDefaultArgs instead
     */
    export type CategoryProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoryProductDefaultArgs instead
     */
    export type SubCategoryProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoryProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDetailDefaultArgs instead
     */
    export type ProductDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SizeDefaultArgs instead
     */
    export type SizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comentsProductDefaultArgs instead
     */
    export type comentsProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comentsProductDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}